---
title: Design of the Miller OTA
subtitle: For a Generic 180nm Bulk CMOS Process (Version 2)
author: Christian Enz (christian.enz@epfl.ch)
affiliation: EPFL
date: today
execute:
  echo: false
  warning: false
toc: true
number-sections: true
number-depth: 3
highlight-style: pygments
bibliography: references.bib
csl: ieee.csl
format: 
  html:
    include-in-header: mathjax.html
    code-fold: true
    html-math-method: mathjax
    css: styles.css
  pdf:
    keep-tex: true
    pdf-engine: pdflatex
    documentclass: scrreprt
    papersize: a4
    geometry: 
      - top=20mm
      - bottom=20mm
      - left=20mm
      - right=20mm
---

```{python}
# Initialization

from ekv_functions import *

import pandas as pd
import matplotlib.pyplot as plt
import subprocess
import shutil
import os
import os.path as op
import sys
sys.path.append(".")
import re

from IPython.display import Markdown
from tabulate import tabulate

plt.rcParams['pdf.fonttype'] = 42
plt.rcParams['font.family'] = 'Arial'
plt.rcParams['mathtext.fontset'] = 'custom'
plt.rcParams['mathtext.rm'] = 'Arial'
plt.rcParams['mathtext.it'] = 'Arial:italic'
plt.rcParams['mathtext.bf'] = 'Arial:bold'
plt.style.use('plt_style_small.mplstyle')
lw=1

otaName="Miller_OTA"
version = "_v1" # Allows you to save different versions
#newDesign=True
newDesign=False
#newSim=True
newSim=False
refloat=r'.*?([+-]?\d+([.]\d*)?([eE][+-]?\d+)?|[.]\d+([eE][+-]?\d+)?)'
```

# Introduction

![Schematic of the Miller OTA.](Figures/Miller_OTA_schematic.png){#fig-miller_ota_schematic}

::: {.callout-note}
Note that all nMOS transistors in @fig-miller_ota_schematic have an odd number and all the pMOS transistors an even number which explains the numbering process.
:::

This notebook presents the analysis, design and simulation of the Miller OTA which schematic is presented in @fig-miller_ota_schematic. The design phase is using the sEKV model and the inversion coefficient approach @bib:enz:book:2006, @bib:enz:sscmag:autumn:2017, @bib:enz:sscmag:winter:2017. The Miller OTA is a two-stage OTA which requires frequency compensation to ensure that it will remain stable in all feedback configurations. The compensation is achieved by adding capacitor $C_c$ which takes advantage of the Miller effect hence its name of Miller compensation or Miller OTA. We will see below that in differential mode the effects of the source transconductances on the common source node voltage are actually canceled.

We will start with a detailed analysis of the OTA which will allow to derive all the design equations that will be used in the design phase. The OTA is then designed for a given set of specifications for a generic 180 nm bulk CMOS technology. The design is then validated by simulations with ngspice @bib:ngspice:2024 using the EKV 2.6 compact model @bib:ekv2p6:doc:rev2:1998 @bib:github:ekv26:va:2025 @bib:grabinski:ekv2p6veriloga:essderc:2019 with parameters corresponding to a generic 180 nm bulk CMOS technology @bib:grabinski:ekv2p6_param_extraction:mixdes:2015 @bib:han:sekv:gitlab:2022.

We now start with the small-signal analysis.

# Analysis
## Small-signal analysis

![Small-signal schematic of the Miller OTA.](Figures/Small_signal_schematic.png){#fig-ssc}

::: {.callout-note}
This small-signal analysis and the frequency compensation analysis is largely based on @bib:allen:book:2012.
:::

We start with the small-signal analysis. The small-signal schematic corresponding to the Miller OTA is shown in @fig-ssc. Assuming perfect matching and differential operation $\Delta V_{Gb1} = -\Delta V_{Ga1} = V_{id}/2$, the voltage at the source of M~1a~-M~1b~ (node 3) remains unchanged and hence $\Delta V_3=0$. The source transconductances can then be omitted leading to the simplified small-signal circuit in differential mode shown in @fig-ssc_dm.

![Small-signal schematic of the Miller OTA in differential mode.](Figures/Small_signal_schematic_dm.png){#fig-ssc_dm}

If the capacitance $C_4$ at the current mirror node 4 is neglected and recalling that $G_4 = G_{m4} + G_{ds4} \cong G_{m4}$, then $\Delta V_4 = -G_{m1}/G_{m4} \cdot V_{id}/2$. The two transconductances connected to node 1 can then be replaced by a single transconductance resulting in the simplified schematic shown in @fig-simplified_ssc_dm.

![Simplified small-signal schematic of the Miller OTA in differential mode.](Figures/Simplified_small_signal_schematic.png){#fig-simplified_ssc_dm}

The small-signal differential gain of the simplified circuit shown in @fig-simplified_ssc_dm is then given by
\begin{align}
  A_{dm} &\triangleq \frac{\Delta V_{out}}{\Delta V_{id}} = A_{dc} \cdot \frac{1-s/z_1}{(1-s/p_1)(1-s/p_2)}\\
  &= A_{dc} \cdot \frac{1+n_1\,s}{1+d_1\,s+d_2\,s^2} = A_{dc} \cdot \frac{1-\frac{s}{z_1}}{1-\frac{s}{p_1+p_2}+\frac{s^2}{p_1\,p_2}}
\end{align}
with
\begin{align}
  A_{dc} &= \frac{G_{m1}}{G_1} \cdot \frac{G_{m2}}{G_2},\\
  n_1 &= -\frac{1}{z_1} = -\frac{C_c}{G_{m2}},\\
  d_1 &= -\left(\frac{1}{p_1}+\frac{1}{p_2}\right)
  = \frac{C_1}{G_1}+\frac{C_2}{G_2}+\frac{C_c}{G_1}\,\left(1+\frac{G_1}{G_2}+\frac{G_{m2}}{G_2}\right),\\
  d_2 &= \frac{1}{p_1\,p_2} = \frac{C_c\,C_2+C_c\,C_1+C_1\,C_2}{G_1\,G_2}.
\end{align}

Note that $G_{m1}/G_1$ and $G_{m2}/G_2$ are the voltage gains of the first and second stage, respectively. $G_1$ and $G_2$ are the total conductances at nodes 1 and 2
\begin{align}
  G_1 &= G_{ds1b} + G_{ds4b},\\
  G_2 &= G_{ds2} + G_{ds5b},
\end{align}
whereas $C_1$ and $C_2$ are the total capacitances at nodes 1 and 2. Note that $C_2$ is usually dominated by $C_L$.

If we ignore the compensation capacitor ($C_c=0$), the zero disappears and the two poles are simply given by
\begin{align}
  p_1' &= -\frac{G_1}{C_1},\\
  p_2' &= -\frac{G_2}{C_2}.
\end{align}
We see that the poles are actually associated to the nodes 1 and 2 (output).

The compensation capacitor introduces a right half-plane (RHP) zero
\begin{equation}
  z_1=\frac{G_{m2}}{C_c}
\end{equation}
and the transfer function $A_{dm}$ has two real poles $p_1$ and $p_2$. Assuming that $C_1 \ll C_2$ and that $G_1$ and $G_2$ are of the same order of magnitude, the poles can be considered as widely separated $|p_1| \ll |p_2|$ then
\begin{equation}
  d_1 \cong -\frac{1}{p_1}
  = \frac{C_1}{G_1}+\frac{C_2}{G_2}+\frac{C_c}{G_1} \cdot \left(1+\frac{G_1}{G_2}+\frac{G_{m2}}{G_2}\right).
\end{equation}
We can further assume that $G_{m2}/G_2 \gg 1$ and the dominant pole $p_1$ is approximately given by
\begin{equation}
  p_1 \cong -\frac{G_1\,G_2}{G_{m2}\,C_c}.
\end{equation}
The gain-bandwidth product $GBW$ is then approximately given by
\begin{equation}
  GBW = |p_1| \cdot A_{dc} \cong \frac{G_{m1}}{C_c}.
\end{equation}
Contrary to the single-stage OTAs (simple OTA, symmetrical OTA, telescopic OTA), the $GBW$ is no more set by the load capacitance but by the compensation capacitance $C_c$. Note that $|p_2|$ must be at least equal to $GBW$ for the above approximation to hold
\begin{equation}
  GBW < \frac{G_{m2}}{C_2}.
\end{equation}

![The mechanism of pole splitting.](Figures/Pole_splitting.png){#fig-pole_splitting}

![The frequency compensation process.](Figures/Compensation.png){#fig-compensation}

The non-dominant pole $p_2$ is then approximately given by
\begin{equation}
  p_2 \cong \frac{1}{p_1\,d_2} \cong -\frac{G_{m2} C_c}{C_c C_2 + C_c C_1 + C_1 C_2}.
\end{equation}
We see that the dominant pole magnitude $|p_1|$ decreases as $C_c$ increases, whereas $|p_2|$ increases as $C_c$ increases. Thus, increasing $C_c$ causes the poles to split apart as illustrated in @fig-pole_splitting. If $C_2$ and $C_c$ can be considered much larger than $C_1$, the non-dominant pole is approximately set by the output capacitance
\begin{equation}
  p_2 \cong -\frac{G_{m2}}{C_2}.
\end{equation}

It can be shown that if the zero is ten times higher than the $GBW$, then in order to achieve a phase margin better than $60^{\circ}$, the second pole must be placed at least 2.2 times higher than the $GBW$. This translates into the following constraints
\begin{align}
  |z_1|> 10\,GBW\;\Rightarrow\;\frac{G_{m2}}{C_c}>10\,\frac{G_{m1}}{C_c}\;\Rightarrow\;G_{m2}>10\,G_{m1},\\
%  |p_2|>2.2\,GBW\;\Rightarrow\;\frca{G_{m2}}{C_o}>2.2\,\frac{G_{m1}}{C_c}.
\end{align}
which results in
\begin{equation}
  C_c > 2.2\,\frac{G_{m1}}{G_{m2}}\,C_2 > 0.22\,C_2.
\end{equation}

The dominant-pole is often called a Miller pole because it takes advantage of the Miller effect. The dominant-pole can actually be found by using the Miller approximation. Using the result obtained earlier without the compensation capacitor and replacing $C_1$ by the Miller capacitance
\begin{equation}
  C_M \cong \frac{G_{m2}}{G_2}\cdot C_2
\end{equation}
results in
\begin{equation}
  p_1 \cong -\frac{G_1 G_2}{G_{m2}\,C_c}
\end{equation}
which is identical to the result found above. However, the Miller approximation does account for the RHP zero. The latter introduces very undesirable effects with regards to stability: it increases the phase shift and at the same time increases the magnitude. The effects of the RHP zero can be mitigated by different means @bib:allen:book:2012.

## Noise analysis

![Small-signal schematic for noise analysis.](Figures/Noise_schematic.png){#fig-noise_schematic}

The small-signal schematic for the noise analysis is shown in @fig-noise_schematic. We can reuse the noise analysis performed for the simple OTA. If we neglect the capacitances at the 1^st^-stage current mirror node and assume a perfect matching, the noise coming from the first stage can be modeled by the noisy current source $I_{n1}$ due to transistors M~1a~-M~1b~ and M~3a~-M~3b~, whereas $I_{n2}$ models the noise coming from transistors M~2~ and M~5b~. The input-referred equivalent noise voltage is then given by
\begin{equation}
  V_{neq} = \frac{I_{n1}}{G_{m1}} - \frac{G_1}{G_{m1}\,G_{m2}} \cdot \frac{1+s\,(C_1+C_c)/G_1}{1-s\,C_c/G_{m2}} \cdot I_{n2}.
\end{equation}
For $\omega \ll G_1/(C_1+C_c)<G_{m2}/C_c$, $V_{neq}$ can be approximated by
\begin{equation}
  V_{neq} \cong \frac{I_{n1}}{G_{m1}} - \frac{G_1}{G_{m1}\,G_{m2}} \cdot I_{n2}.
\end{equation}

The input-referred PSD is then given by
\begin{equation}
  S_{V_{neq}} \cong \frac{S_{I_{n1}}}{G_{m1}^2} + \left(\frac{G_1}{G_{m1}\,G_{m2}}\right)^2 \cdot S_{I_{n2}}.
\end{equation}

### Input-referred thermal noise
For thermal noise we have
\begin{align}
  S_{I_{n1}} &= 4 kT \cdot 2 \cdot (\gamma_{n1} \cdot G_{m1}+\gamma_{n4} \cdot G_{m4}),\\
  S_{I_{n2}} &= 4 kT \cdot (\gamma_{n2} \cdot G_{m2}+2\gamma_{n5} \cdot G_{m5}).
\end{align}

The input-referred thermal noise resistance $R_{nin,th}$ is then given by
\begin{equation}
  R_{nin,th} = \frac{2 \gamma_{n1}}{G_{m1}} \cdot (1 + \eta_{th})
\end{equation}
where
\begin{equation}
  \eta_{th} = \frac{\gamma_{n4}}{\gamma_{n1}}\,\frac{G_{m4}}{G_{m1}} + \frac{G_1^2}{2 G_{m1}\,G_{m2}} \cdot \left(\frac{\gamma_{n2}}{\gamma_{n1}} + \frac{2\gamma_{n5}}{\gamma_{n1}} \cdot \frac{G_{m5}}{G_{m2}}\right)
\end{equation}
is the contribution of the current mirror M~4a~-M~4b~, 2^nd^-stage M~2~ and current mirror M~5a~-M~5b~ relative to that of the differential pair M~1a~-M~1b~.

The input-referred thermal noise resistance $R_{nin,th}$ can also be written as
\begin{equation}
  R_{nin,th} = \frac{\gamma_{neq}}{G_{m1}}
\end{equation}
where $\gamma_{neq}$ is the amplifier equivalent thermal noise excess factor given by
\begin{equation}
  \gamma_{neq}= 2\,\gamma_{n1}\,(1+\eta_{th}) = 2\,\gamma_{n1}\,\left[1 + \frac{\gamma_{n4}}{\gamma_{n1}}\,\frac{G_{m4}}{G_{m1}} + \frac{G_1^2}{2 G_{m1}\,G_{m2}} \cdot \left(\frac{\gamma_{n2}}{\gamma_{n1}} + \frac{2\gamma_{n5}}{\gamma_{n1}} \cdot \frac{G_{m5}}{G_{m2}}\right)\right].
\end{equation}
We see that the contribution of the current mirror M~4a~-M~4b~ can be minimized by choosing $G_{m1} \gg G_{m4}$ (same as for the simple OTA). The contribution of M~2~ and M~5a~-M~5b~ are small thanks to the term
\begin{equation}
  \frac{G_1^2}{2 G_{m1}\,G_{m2}} = \frac{(G_{ds1}+G_{ds4})^2}{2 G_{m1}\,G_{m2}} \gg 1 
\end{equation}
which is in the order of the DC gain. The contribution of the current mirror M~5a~-M~5b~ can be made negligible by choosing $G_{m2} \gg G_{m5}$.

### Input-referred flicker noise
For flicker noise we have
\begin{align}
  S_{I_{n1}} &= \frac{4 kT}{f} \cdot 2 \cdot \left(G_{m1}^2\,\frac{\rho_n}{W_1 L_1} + G_{m4}^2\,\frac{\rho_p}{W_4 L_4}\right),\\
  S_{I_{n2}} &= \frac{4 kT}{f} \cdot \left(G_{m2}^2\,\frac{\rho_p}{W_2 L_2} + 2 G_{m5}^2\,\frac{\rho_n}{W_5 L_5}\right).
\end{align}

The input-referred flicker noise resistance is then given by
\begin{equation}
  f \cdot R_{nin,fl} = 2\,\left[\frac{\rho_n}{W_1 L_1} + \left(\frac{G_{m4}}{G_{m1}}\right)^2\,\frac{\rho_p}{W_4 L_4}\right] + \left(\frac{G_1}{G_{m1}}\right)^2\,\left[\frac{\rho_p}{W_2 L_2} + 2\left(\frac{G_{m5}}{G_{m2}}\right)^2\,\frac{\rho_n}{W_5 L_5}\right]
\end{equation}
which can be written in terms of the individual contributions relative to that of the differential pair
\begin{equation}
  f \cdot R_{nin,fl} = \frac{2 \rho_n}{W_1 L_1} \cdot (1+\eta_{fl}),
\end{equation}
with
\begin{equation}
  \eta_{fl} = \left(\frac{G_{m4}}{G_{m1}}\right)^2\,\frac{\rho_p}{\rho_n}\,\frac{W_1 L_1}{W_4 L_4} + \frac{1}{2}\,\left(\frac{G_1}{G_{m1}}\right)^2\,\left[\frac{\rho_p}{\rho_n}\,\frac{W_1 L_1}{W_2 L_2} + 2\left(\frac{G_{m5}}{G_{m1}}\right)^2\,\frac{W_1 L_1}{W_5 L_5}\right].
\end{equation}

We see that the contribution of the current mirror M~4a~-M~4b~ can be minimized by choosing $G_{m1} \gg G_{m4}$ (same as for the simple OTA). The contribution of M~2~ and M~5a~-M~5b~ are small thanks to the first stage gain
\begin{equation}
  \left(\frac{G_1}{G_{m1}}\right)^2 = \left(\frac{G_{ds1}+G_{ds4}}{G_{m1}}\right)^2 \gg 1.
\end{equation}
The contribution of the current source M~5a~-M~5b~ can be made negligible by choosing $G_{m2} \gg G_{m5}$.

## Input-referred offset voltage

![Small-signal schematic for mismatch analysis.](Figures/Mismatch_schematic.png){#fig-mismatch_schematic}

The estimation of the offset voltage can be handled similarly to the noise. It is essentially due to the first stage and is therefore similar to what was done for the simple OTA. Using the schematic shown in @fig-mismatch_schematic, we can derive the input-referred offset voltage variance as
\begin{equation}
  \sigma_{V_{os}}^2 = \sigma_{VT1}^2 + \left(\frac{G_{m4}}{G_{m1}}\right)^2 \cdot \sigma_{VT4}^2 + \left(\frac{I_b}{G_{m1}}\right)^2 \cdot \left(\sigma_{\beta 1}^2 + \sigma_{\beta 4}^2\right)
\end{equation}
where
\begin{align}
  \sigma_{VT1}^2 &= \frac{A_{VTn}^2}{W_1 L_1},\\
  \sigma_{VT4}^2 &= \frac{A_{VTp}^2}{W_4 L_4},\\
  \sigma_{\beta 1}^2 &= \frac{A_{\beta n}^2}{W_1 L_1},\\
  \sigma_{\beta 4}^2 &= \frac{A_{\beta_p}^2}{W_4 L_4}.
\end{align}

We can rewrite the variance of the input-referred offset separating the contributions of the $V_T$- and $\beta$-mismatch
\begin{equation}
  \sigma_{V_{os}}^2 = \sigma_{V_T}^2 + \sigma_{\beta}^2
\end{equation}
where
\begin{equation}
  \sigma_{V_T}^2 = \sigma_{V_{T1}}^2 \cdot (1 + \xi_{V_T})
\end{equation}
and
\begin{equation}
  \sigma_{\beta}^2 = \left(\frac{I_b}{G_{m1}}\right)^2 \cdot \sigma_{\beta_1}^2 \cdot (1 + \xi_{\beta}).
\end{equation}
$\xi_{V_T}$ represents the $V_T$-mismatch contributions to the input-referred offset of the current mirror relative to that of the differential pair
\begin{equation}
  \xi_{V_T} = \left(\frac{G_{m4}}{G_{m1}}\right)^2 \cdot \left(\frac{A_{VTp}}{A_{VTn}}\right)^2 \cdot \frac{W_1 L_1}{W_4 L_4}
\end{equation}
and $\xi_{\beta}$ represents the $\beta$-mismatch contributions to the input-referred offset of the current mirror relative to that of the differential pair
\begin{equation}
  \xi_{\beta} = \left(\frac{A_{\beta p}}{A_{\beta n}}\right)^2 \cdot \frac{W_1 L_1}{W_4 L_4}.
\end{equation}

Having done the small-signal, noise and offset analysis, we can now proceed with the design.

# Design
## Specifications
The OTA specifications are given in @tbl-ota_specs.

::: {.callout-note}
The specifications given in @tbl-ota_specs are simplified specifications. They are mainly targeting the achievement of a certain gain-bandwidth product $GBW$ and DC gain at lowest current consumption. The $GBW$ sets the differential pair transconductance while the DC gain sets the output conductance. There is an additional specification on the random input-referred offset voltage which, if not met, might eventually require to increase the transistors area. There are no specifications on thermal noise since the transconductance is set by the $GBW$. There are no specifications on the flicker noise but if the corner frequency was set lower this would required to increase the transistors area. There are also no specifications on the slew-rate, which might be small because of the low-power objective. Finally, there are many more specifications such as CMRR, PSRR, input common-mode voltage range, output-voltage swing, etc... that are not discussed in this example.
:::

```{python}
#| label: tbl-ota_specs
#| tbl-cap: OTA specifications.

from specs import *

Adc=10**(AdcdB/20)
wu=2*pi*GBWspec
table = [["Minimum DC gain","$A_{{dc}}$",f'{AdcdB:.0f}',"$dB$"],
         ["Minimum gain-bandwidth product","$GBW$",f'{GBWspec/1e6:.3f}',"$MHz$"],
         ["Load capacitance","$C_L$",f'{CL/1e-12:.0f}',"$pF$"],
         ["Maximum input-referred random offset voltage","$V_{{os}}$",f'{Vosmax/1e-3:.0f}',"$mV$"],
         ["Phase margin","$PM$",f'{PMdeg:.0f}',"$^{\\circ}$"]
         ]
Markdown(tabulate(
  table,
  headers=["Specification","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center")
))
```

## Process
We will design the cascode gain stage for a generic 180nm bulk CMOS process. The physical parameters are given in @tbl-physics_param, the global process parameters in @tbl-process_param and finally the MOSFET parameters in @tbl-mos_param. 

```{python}
#| label: tbl-physics_param
#| tbl-cap: Physical parameters

from tsmc018_sekv_ekv2p6 import *

table = [["$T$",f'{T:.0f}',"$K$"],
         ["$U_T$",f'{UT/1e-3:.3f}',"$mV$"]
         ]

Markdown(tabulate(
  table,
  headers=["Parameter","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center", "center", "center")
))
```

```{python}
#| label: tbl-process_param
#| tbl-cap: Global process parameters

from tsmc018_sekv_ekv2p6 import *

table = [["$V_{DD}$",f'{VDD:.1f}',"$V$"],
         ["$C_{ox}$",f'{Cox*1e3:.3f}',"$\\frac{fF}{\\mu m^2}$"],
         ["$W_{min}$",f'{Wmin/1e-9:.0f}',"$nm$"],
         ["$L_{min}$",f'{Lmin/1e-9:.0f}',"$nm$"]
         ]

Markdown(tabulate(
  table,
  headers=["Parameter","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center", "center", "center")
))
```

```{python}
#| label: tbl-mos_param
#| tbl-cap: Transistor process parameters

from tsmc018_sekv_ekv2p6 import *

table = [["sEKV parameters"],
         ["$n$",f'{n0n:.2f}',f'{n0p:.2f}',"-"],
         ["$I_{{spec\\Box}}$",f'{Ispecsqn/1e-9:.0f}',f'{Ispecsqn/1e-9:.0f}',"$nA$"],
         ["$V_{{T0}}$",f'{VT0n:.3f}',f'{VT0p:.3f}',"$V$"],
         ["$L_{{sat}}$",f'{Lsatn/1e-9:.0f}',f'{Lsatp/1e-9:.0f}',"$nm$"],
         ["$\\lambda$",f'{lambdan*1e-6:.0f}',f'{lambdap*1e-6:.0f}',"$\\frac{{V}}{{\\mu m}}$"],
         ["Overlap capacitances parameters"],
         ["$C_{{GDo}}$",f'{CGDOn*1e9:.3f}',f'{CGDOp*1e9:.3f}','$\\frac{{fF}}{{\\mu m}}$'],
         ["$C_{{GSo}}$",f'{CGSOn*1e9:.3f}',f'{CGSOp*1e9:.3f}','$\\frac{{fF}}{{\\mu m}}$'],
         ["$C_{{GBo}}$",f'{CGBOn*1e9:.3f}',f'{CGBOp*1e9:.3f}','$\\frac{{fF}}{{\\mu m}}$'],
         ["Junction capacitances parameters"],
         ["$C_J$",f'{CJn*1e3:.3f}',f'{CJp*1e3:.3f}','$\\frac{{fF}}{{\\mu m^2}}$'],
         ["$C_{{JSW}}$",f'{CJSWn*1e9:.3f}',f'{CJSWp*1e9:.3f}','$\\frac{{fF}}{{\\mu m}}$'],
         ["Flicker noise parameters"],
         ["$K_F$",f'{KFn:.1e}',f'{KFn:.1e}',"$J$"],
         ["$AF$",f'{AFn:.1f}',f'{AFp:.1f}',"-"],
         ["$\\rho$",f'{rhon:.3e}',f'{rhop:.3e}','$\\frac{{V \\cdot m^2}}{{A \\cdot s}}$'],
         ["Matching parameters"],
         ["$A_{{VT}}$",f'{AVTn*1e9:.0f}',f'{AVTp*1e9:.0f}',"$mV \\cdot \\mu m$"],
         ["$A_{{\\beta}}$",f'{Abetan*1e8:.0f}',f'{Abetap*1e8:.0f}',"$\\% \\cdot \\mu m$"],
         ["Source and drain sheet resistance parameter"],
         ["$R_{{sh}}$",f'{RSHn:.0f}',f'{RSHp:.0f}',"$\\frac{{\\Omega}}{{\\mu m}}$"],
         ["Width and length parameters"],
         ["$\\Delta W$",f'{DWn/1e-9:.0f}',f'{DWp/1e-9:.0f}',"$\\,nm$"],
         ["$\\Delta L$",f'{DLn/1e-9:.0f}',f'{DLp/1e-9:.0f}',"$\\,nm$"]
         ]

Markdown(tabulate(
  table,
  headers=["Parameter","NMOS","PMOS","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center", "center", "center")
))
```

## Design procedure
If the DC gain of the second stage $G_{m2}/G_2$ can be assumed to be much larger than 1, the dominant pole can be approximated by
\begin{equation}
  \omega_{p1} = |p_1| \cong \frac{G_1\,G_2}{G_{m2}\,C_c}.
\end{equation}

Since $C_1$ is a parasitic capacitance, it is reasonable to consider that it is much smaller than the compensation capacitance $C_c$ and the load capacitance $C_L$. Both assumptions $C_1 \ll C_c$ and $C_1 \ll C_L$ lead to the following approximation of the non-dominant pole
\begin{equation}
  \omega_{p2} = |p_2| \cong \frac{G_{m2}}{C_L}.
\end{equation}
In the design procedure we need to make sure that the non-dominant pole $\omega_{p2}$ and the RHP zero $\omega_z=G_{m2}/C_c$ are sufficiently larger than the $GBW$ in order to secure enough phase margin. The ratio of the non-dominant pole and the zero to the unity gain frequency are given by
\begin{align}
  \frac{\omega_{p2}}{\omega_u} &= \frac{G_{m2}}{G_{m1}} \cdot \frac{C_c}{C_L},\\
  \frac{\omega_z}{\omega_u} &= \frac{G_{m2}}{G_{m1}}
\end{align}
and hence
\begin{align}
  \frac{\omega_{p2}}{\omega_u} &= \frac{\omega_z}{\omega_u} \cdot \frac{C_c}{C_L},\\
  \frac{\omega_z}{\omega_{p2}} &= \frac{C_L}{C_c}.
\end{align}
The unity gain frequency $\omega_u$, non-dominant pole $\omega_{p2}$ and zero $\omega_z$ need to satisfy
\begin{equation}
  \omega_u < \omega_{p2} < \omega_z,
\end{equation}
or
\begin{equation}
  1 < \frac{\omega_{p2}}{\omega_u} < \frac{\omega_z}{\omega_u}.
\end{equation}
This translates to the following inequality
\begin{equation}
  1 < \frac{C_L}{C_c} < \frac{G_{m2}}{G_{m1}}.
\end{equation}
This means that the compensation capacitance $C_c$ should stay smaller than the load capacitance $C_L$ and that the ratio  of the transconductance of M~2~ to that of M~1~ should be larger than $C_L/C_c$.

Usually the compensation capacitance $C_c$ is a fraction of the load capacitance $C_L$ which can be determined from the specified phase margin $PM$ which is given by
\begin{equation}
  PM = \arctan\left(\frac{\omega_u}{\omega_z}\right)+\arctan\left(\frac{\omega_u}{\omega_{p2}}\right)-\frac{\pi}{2}.
\end{equation}

```{python}
wp2_over_wu=4
wz_over_wp2=2
wz_over_wu=wp2_over_wu*wz_over_wp2
PM=pi/2-atan(1/wz_over_wu)-atan(1/wp2_over_wu)
PMdeg=180/pi*PM
Cc=CL/2
wu=2*pi*GBWspec
Gm1=wu*Cc
Ib1min=n0n*UT*Gm1
Itotmin=10*Ib1min
Gm2=8*Gm1
IC1=0.1
Ib1=n0n*UT*Gm1/gmsid_ic(IC1)
```

For example if $\omega_{p2}/\omega_u =$ `{python} f'{wp2_over_wu:.0f}'` and $\omega_z/\omega_{p2} =$ `{python} f'{wz_over_wp2:.0f}'`, then $\omega_z/\omega_u =$ `{python} f'{wz_over_wu:.0f}'` and $PM =$ `{python} f'{PMdeg:.3f}'` $^{\circ}$, which is usually more than sufficient. However we need to account for parasitic capacitances which add to the load capacitance and reduce the non-dominant pole. Therefore a good trade-off to start the design and achieve a sufficient $PM$ (typically larger than 45 degree) is to choose $\omega_{p2} =$ `{python} f'{wp2_over_wu:.0f}'` $\omega_u$, and $\omega_z =$ `{python} f'{wz_over_wp2:.0f}'` $\omega_{p2} =$ `{python} f'{wz_over_wu:.0f}'` $\omega_u$. This results in choosing

$C_c = \frac{C_L}{\omega_z/\omega_{p2}} = C_L/$ `{python} f'{wz_over_wp2:.0f} = {Cc/1e-12:.1f}'` pF.

It is important to note that choosing $\omega_z/\omega_u=G_{m2}/G_{m1}=$ `{python} f'{wz_over_wu:.0f}'` for securing enough phase margin has a direct impact on the power consumption. Indeed, if we assume that both M~1a~-M~1b~ and M~2~ are biased in weak inversion for maximizing the current efficiency, then $G_{m1}=I_{b1}/(n_n\,U_T)$ and $G_{m2}=I_{b2}/(n_p\,U_T)$. Assuming that $n_n=n_p$, $G_{m2}/G_{m1} = I_{b2}/I_{b1} = \omega_z/\omega_u =$ `{python} f'{wz_over_wu:.0f}'`. This means that the bias current of M~2~ is `{python} f'{wz_over_wu:.0f}'` times larger than that of M~1a~-M~1b~! The total current consumption, without accounting for the current flowing in M~3a~ and M~5a~, is then $I_{tot} = 2 I_{b1} + I_{b2} =$ `{python} f'{2+wz_over_wu:.0f}'` $\,I_{b1}$. We can express the minimum total current consumption in terms of the gain-bandwidth product $GBW$ as $I_{tot} \cong$ `{python} f'{2+wz_over_wu:.0f}'` $\,n U_T \cdot C_c \cdot GBW =$ `{python} f'{1+wz_over_wu/2:.0f}'` $\,n U_T \cdot C_L \cdot GBW$. This can be compared to the total current consumption of the symmetrical cascode OTA $I_{tot} = 4\,n U_T \cdot C_L \cdot GBW$. We deduce that for the same gain-bandwidth product $GBW$ and load capacitance $C_L$, the Miller OTA consumes about 25\% more current than the symmetrical cascode OTA.


### Sizing the differential pair M~1a~-M~1b~
We can now size the differential pair M~1a~-M~1b~ knowing that its transconductance is set by the gain-bandwidth product $GBW$ and the compensation capacitance $C_c$ according to $G_{m1} = \omega_u \cdot C_c =$ `{python} f'{Gm1/1e-6:.3f}'` $\mu A/V$. The minimum current to achieve this transconductance assuming that M~1a~-M~1b~ are biased in deep weak inversion is given by $I_{b1,min} =$ `{python} f'{Ib1min/1e-9:.0f}'` $nA$. We know that the differential pair M~1a~-M~1b~ should be biased in weak inversion in order to minimize the input-referred offset. If we set the inversion coefficient of M~1a~-M~1b~ to $IC_1=$ `{python} f'{IC1:.1f}'`, the required bias current $I_{b1}$ for M~1a~-M~1b~ to achieve $G_{m1} =$ `{python} f'{Gm1/1e-6:.3f}'` $\mu A/V$ with $IC_1=$ `{python} f'{IC1:.1f}'` is then given by $I_{b1}=$ `{python} f'{Ib1/1e-9:.0f}'` $nA$.

```{python}
Ib1=130E-9
Gm1=Ib1/(n0n*UT)*gmsid_ic(IC1)
GBWthe=Gm1/(2*pi*Cc)
Ispec1=Ib1/IC1
WoverL1=Ispec1/Ispecsqn
```

Let's take some margin and set $I_{b1}=$ `{python} f'{Ib1/1e-9:.0f}'` $nA$. The transconductance can be recalculated from the $G_m/I_D$ function as $G_{m1} =$ `{python} f'{Gm1/1e-6:.3f}'` $\mu A/V$. The corresponding $GBW$ is then given by $GBW =$ `{python} f'{GBWthe/1e6:.1f}'` $MHz$, which is slightly higher than the target specification offering some margin. The specific current is then given by $I_{spec1} =$ `{python} f'{Ispec1/1e-6:.1f}'` $\mu A$ and the aspect ratio  by $W_1/L_1 =$ `{python} f'{WoverL1:.1f}'`. The length $L_1$ will be calculated below from the specifications on the DC gain.

The biasing of M~2~ should however be compatible with that of M~4a~-M~4b~. The latter should be biased in strong inversion for better matching but also to achieve a transconductance $G_{m4}$ smaller than $G_{m1}$ in order to reduce its noise contribution. So we will first size M~4a~-M~4b~.

### Sizing the pMOS current mirror M~4a~-M~4b~

```{python}
Vicmax=1.45
VS1=0.4
VGS1=VT0n+(n0n-1)*VS1
#VGS1=VT0n+n0n*UT*vps_ic(IC1)
VDSsat1=UT*vdssat_ic(IC1)
VSG4=VDD-Vicmax+VGS1-VDSsat1
IC4=ic_vps((VSG4-VT0p)/(n0p*UT))
VDSsat4=n0p*UT*vdssat_ic(IC4)
Ispec4=Ib1/IC4
WoverL4=Ispec4/Ispecsqp
Gm4=Ispec4/(n0p*UT)*gms_ic(IC4)
```

The maximum gate voltage of M~4a~ is set by the maximum common mode input voltage still keeping M~1a~ in saturation according to
\begin{equation}
  V_{SG4} = V_{DD} - V_{icmax} + V_{GS1} - V_{DSsat1}.
\end{equation}
The gate-to-source voltage $V_{GS1}$ is given by
\begin{equation}
  V_{GS1} = V_{T0n} + (n_{0n}-1)\,V_{S1} + n_{0n} \, U_T \, (v_p-v_s).
\end{equation}
Unfortunately, at this point we don't know the value of the source voltage $V_{S1}$ of M~1a~-M~1b~ (voltage at common-source node 1). In weak inversion $v_p-v_s \cong 0$ so that
\begin{equation}
  V_{GS1} \cong V_{T0n} + (n_{0n}-1)\,V_{S1}
\end{equation}
For a common-mode input voltage $V_{ic}$ set at $V_{DD}/2 =$ `{python} f'{VDD/2:.1f}'`, we estimate $V_{S1}$ to be about $V_{S1} =$ `{python} f'{VS1/1e-3:.0f}'` $mV$. This gives $V_{GS1} \cong$ `{python} f'{VGS1/1e-3:.0f}'` $mV$. The saturation voltage $V_{DSsat1}$ of M~1a~-M~1b~ is given by $V_{DSsat1}  =$ `{python} f'{VDSsat1/1e-3:.0f}'` $mV$.

For a maximum input common-mode voltage given by $V_{ic,max} =$ `{python} f'{Vicmax:.2f}'` $V$, the maximum source-to-gate voltage of M~4a~-M~4b~ $V_{SG4}$ is equal to $V_{SG4} =$ `{python} f'{VSG4/1e-3:.0f}'` $mV$, which corresponds to an inversion coefficient $IC_4 =$ `{python} f'{IC4:.3f}'` and a saturation voltage $V_{DSsat4}  =$ `{python} f'{VDSsat4/1e-3:.0f}'` $mV$. The specific current is equal to $I_{spec4} =$ `{python} f'{Ispec4/1e-9:.2f}'` $nA$, the aspect ratio to $W_4/L_4 =$ `{python} f'{WoverL4:.3f}'` and the transconductance to $G_{m4}  =$ `{python} f'{Gm4/1e-6:.3f}'` $\mu A/V$.

```{python}
Adc=pow(10,AdcdB/20)
Adc1=sqrt(Adc)
G1=Gm1/Adc1
L1=2/G1*Ib1/lambdan
L1=round(1E8*L1)/1E8
W1=WoverL1*L1
W1=round(1E8*W1)/1E8
L4=2/G1*Ib1/lambdap
L4=round(1E8*L4)/1E8
W4=WoverL4*L4
W4=round(1E8*W4)/1E8
```

We will use the specification on the DC gain to set the length of the various transistors. The DC gain is given by $A_{dc} = A_{dc1} \cdot A_{dc2} =$ `{python} f'{Adc:.0e}'`, where $A_{dc1}$ and $A_{dc2}$ are the DC gains of the first and second stage, respectively. We can distribute the DC gain equally among the first and second stage so that $A_{dc1} = A_{dc2} =$ `{python} f'{Adc1:.1f}'`.

The conductance $G_1$ at node 1 is then given by $G_1  =$ `{python} f'{G1/1e-9:.3f}'` $nA/V$. $G_1$ depends on the output conductances of M~1b~ and M~4b~ according to $G_1 = G_{ds1b} + G_{ds4b}$. We can split it half-half between M~1b~ and M~4b~, which leads to the length of M~1b~ $L_1 =$ `{python} f'{L1/1e-6:.2f}'` $\mu m$, from which we get the width $W_1 =$ `{python} f'{W1/1e-6:.2f}'` $\mu m$.

```{python}
L4=2/G1*Ib1/lambdap
L4=round(1E8*L4)/1E8
W4=WoverL4*L4
W4=round(1E8*W4)/1E8
```

Similarly for M~4~ we get the length from the output conductance $G_{ds4}$ as $L_4 =$ `{python} f'{L4/1e-6:.2f}'` $\mu m$, from which we get the width $W_4 =$ `{python} f'{W4/1e-9:.2f}'` $nm$, which is smaller than the minimum width $W_{min} =$ `{python} f'{Wmin/1e-9:.0f}'` $nm$.

```{python}
W4=Wmin
W4ini=W4
L4=W4/WoverL4
L4=round(1E8*L4)/1E8
L4ini=L4
```

We then set $W_4$ to the minimum width $W_4 = W_{min} =$ `{python} f'{W4/1e-9:.0f}'` $nm$ and get the length $L_4 =$ `{python} f'{L4/1e-6:.2f}'` $\mu m$.

```{python}
Ispec4=Ispecsqp*W4/L4
IC4=Ib1/Ispec4
Gm4=Ispec4/(n0p*UT)*gms_ic(IC4)
etafl4=(Gm4/Gm1)**2*rhop/rhon*(W1*L1)/(W4*L4)
```

We can estimate the relative contribution of M~4a~-M~4b~ to the input-referred flicker noise PSD from
\begin{equation}
  \left.\eta_{fl}\right|_{M_{4a}\textsf{-}M_{4b}} = \left(\frac{G_{m4}}{G_{m1}}\right)^2\,\frac{\rho_p}{\rho_n}\,\frac{W_1 L_1}{W_4 L_4}.
\end{equation}
which is equal to `{python} f'{etafl4:.3f}'`. This means that the contribution of M~4a~-M~4b~ to the input-referred flicker is about `{python} f'{etafl4:.3f}'` that of M~1a~-M~1b~. This is reasonable accounting for the large $\rho_p/\rho_n =$ `{python} f'{rhop/rhon:.3f}'` factor.

### Sizing the second-stage M~2~

```{python}
Gm2=8*Gm1
Adc2=Adc1
```

We now set $G_{m2}$ to `{python} f'{wz_over_wu:.0f}'` times the recalculated value of $G_{m1}$ resulting in $G_{m2}  =$ `{python} f'{Gm2/1e-6:.3f}'` $\mu A/V$. To size M~2~, we first calculate the second stage voltage gain $A_{dc2} =$ `{python} f'{Adc2:.1f}'`.

The sizing of M~2~ is tricky. Indeed, ideally, for low-power we would choose to bias M~2~ in weak inversion for a maximum current efficiency. This will set the bulk-to-gate voltage of M~2~ to about $V_{T0p}$. On the other hand the quiescent voltage at node 1 (gate of M~2~) is equal to that of node 4 which is equal to $V_{SG4}$. Having chosen to bias M~4a~-M~4b~ in strong inversion results in $V_{SG4}$ to be larger than $V_{T0p}$ by the overdrive voltage of M~4a~-M~4b~, $V_{SG4}-V_{T0p}$. Therefore the bulk-to-gate voltage of M~2~ is actually larger than $V_{T0p}$ and since M~2~ is biased in weak inversion, the current that M~2~ would need to carry is much larger than the current imposed by the current source M~5b~. The only degree of freedom left is the source-to-drain voltage of M~2~ which becomes very small to reduce the current to the level of the bias current imposed by M~5b~. M~2~ is therefore biased in the linear region with a source-to-drain voltage close to zero. That means that the output voltage will saturate to $V_{DD}$. In order to bring the output voltage back into the high gain region (for example equal to the input common-mode voltage), a differential input voltage needs to be applied which actually corresponds to a systematic offset which can be quite large. If the OTA is used in a closed-loop configuration, which is usually the case, this offset voltage should not be a problem.

A more important consequence of biasing M~2~ in weak inversion is that this results in a very large transistor increasing the parasitic capacitance at node 1 and therefore reducing the non-dominant pole and hence the phase margin. Increasing the inversion coefficient $IC_2$ keeping the same transconductance $G_{m2}$ and DC gain $A_{dc2} = G_{m2}/G_2$ (or keeping the same conductance $G_2$), reduces the gate area of M~2~ at the cost of less current efficiency.

To find what is the optimum inversion coefficient for M~2~ that minimizes the parasitic capacitance at node 1 and secures enough phase margin, we can plot its area $W_2\,L_2$ versus $IC_2$ for a given value of $G_{m2}$ and of the second stage gain $A_{dc2}$ which is presented in @fig-wl_ic.

```{python}
#| label: fig-wl_ic
#| fig-cap: "Gate area $W_2 L_2$ versus inversion coefficient $IC_2$ for given $G_{m2}$ and dc gain $A_{dc2}$."

def WL(IC2,Gm2,Adc2):
    Ib2=Gm2*n0p*UT/gmsid_ic(IC2)
    Ispec2=Ib2/IC2
    WoverL2=Ispec2/Ispecsqp
    G2=Gm2/Adc2
    L2=2/G2*Ib2/lambdap
    W2=WoverL2*L2
    return W2*L2

Npts=101
logICmin=-2
logICmax=2
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
ICsw=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)
WL2=np.zeros(Npts)

for k in range(0,Npts):
    WL2[k]=WL(ICsw[k],Gm2,Adc2)

WL2min=min(WL2)
idxmin=np.where(WL2 == WL2min)[0]
IC2min=ICsw[idxmin][0]

plt.loglog([ICmin,IC2min],[WL2min/1e-12,WL2min/1e-12],'k--', linewidth=lw)
plt.loglog([IC2min,IC2min],[1e0,WL2min/1e-12],'k--', linewidth=lw)
plt.loglog(ICsw,WL2/1e-12,'r')
plt.xlim(ICmin,ICmax)
plt.xlabel('$IC_2$ [-]')
plt.ylabel('$W_2\\,L_2 \\quad [\\mu m^2]$')
plt.ylim(1e1,1e3)
textstr = '\n'.join((
  f'$G_{{m2}} =$ {Gm2/1e-6:.3f} $\\mu A/V$',
  f'$A_{{dc2}} =$ {Adc2:.1f}',
  f'$IC_{{2,min}} =$ {IC2min:.1f}',
  f'$W_2\\,L_2 =$ {WL2min/1e-12:.1f} $\\mu m^2$'))
plt.text(0.6, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.text(8e-2, WL2min/1e-12, f'$W_2\\,L_{{2,min}} =$ {WL2min/1e-12:.1f}', ha='center', va='bottom', size=9)
plt.text(2.5, 11, f'$IC_{{2,min}} =$ {IC2min:.1f}', ha='left', va='bottom', size=9)
plt.show()
```

```{python}
IC2=IC2min
Ib2=Gm2*n0p*UT/gmsid_ic(IC2)
Ib2min=Gm2*n0p*UT
Ib2ratio=Ib2/Ib2min
```

From @fig-wl_ic, we observe that there is an optimum value of $IC_2$ for which the area of M~2~ and hence its related parasitic capacitance are minimum. This optimum $IC$ is in the moderate inversion. Let's now set $IC_2$ to this optimum value $IC_2 = IC_{2,min} =$ `{python} f'{IC2:.1f}'`. The current can be derived from $G_{m2}$ and the $G_m/I_D$ ratio as $I_{b2} =$ `{python} f'{Ib2/1e-6:.3f}'` $\mu A$, which is about twice the minimum value we would get if M~2~ is biased in weak inversion $I_{b2}/I_{b2,min} =$ `{python} f'{Ib2ratio:.1f}'`.

```{python}
Ib2=2e-6
Gm2=Ib2/(n0p*UT)*gmsid_ic(IC2)
Ispec2=Ib2/IC2
WoverL2=Ispec2/Ispecsqp
G2=Gm2/Adc2
L2=2/G2*Ib2/lambdap
L2=round(1E8*L2)/1E8
W2=WoverL2*L2
W2=round(1E8*W2)/1E8
L5=2/G2*Ib2/lambdan
L5=round(1E8*L5)/1E8
VDSsat5=0.3
IC5=ic_vdssat(VDSsat5/UT)
Ispec5=Ib2/IC5
WoverL5=Ispec5/Ispecsqn
W5=WoverL5*L5
W5=round(1E8*W5)/1E8
```

We round $I_{b2}$ to `{python} f'{Ib2/1e-6:.1f}'` $\mu A$. We can now recompute $G_{m2}$ as $G_{m2}  =$ `{python} f'{Gm2/1e-6:.3f}'` $\mu A/V$ and derive the specific current $I_{spec2} =$ `{python} f'{Ispec2/1e-9:.2f}'` $nA$ and aspect ratio $W_2/L_2 =$ `{python} f'{WoverL2:.3f}'`. The conductance $G_2$ at the output node is then given by $G_2  =$ `{python} f'{G2/1e-9:.1f}'` $nA/V$, which we split equally among M~2~ and M~5b~ leading to $L_2 =$ `{python} f'{L2/1e-6:.2f}'` $\mu m$, from which we get the width $W_2 =$ `{python} f'{W2/1e-6:.2f}'` $\mu m$. M~2~ is now fully sized.

### Sizing the nMOS current mirrors M~5a~-M~5b~
Similarly for M~5b~ we get $L_5 =$ `{python} f'{L5/1e-6:.2f}'` $\mu m$ from the gain of the 2^nd^ stage $A_{dc2} =$ `{python} f'{Adc2:.0f}'`. To finalize the sizing of M~5b~ we can set its saturation voltage to $V_{DSsat5}  =$ `{python} f'{VDSsat5/1e-3:.0f}'` $mV$, which corresponds to an inversion coefficient equal to $IC_5 =$ `{python} f'{IC5:.1f}'`. Having $I_D$ and $IC$ we get $W_5/L_5 =$ `{python} f'{WoverL5:.1e}'` and finally its width $W_5 =$ `{python} f'{W5/1e-9:.0f}'` $nm$.

```{python}
Vicmin=0.87
VDSsat3=Vicmin-VGS1
IC3=ic_vdssat(VDSsat3/UT)
Ispec3=2*Ib1/IC3
WoverL3=Ispec3/Ispecsqn
W3=Wmin
L3=W3/WoverL3
L3=round(1E8*L3)/1E8
```

### Sizing the nMOS current mirrors M~3a~-M~3b~
Because of the substrate effect, the $V_{GS1}$ voltage of M~1a~-M~1b~ is rather large $V_{GS1} =$ `{python} f'{VGS1/1e-3:.0f}'` $mV$. Therefore the minimum common-mode input voltage is quite limited. On the other hand we want the current mirror M~3a~-M~3b~ to be biased as far in strong inversion as possible. If we choose $V_{ic,min} =$ `{python} f'{Vicmin:.2f}'` $V$, which leads to the saturation voltage of M~3b~ equal to $V_{DSsat3} = V_{ic,min} - V_{GS1} =$  `{python} f'{VDSsat3/1e-3:.0f}'` $mV$. We can derive the corresponding inversion coefficient as $IC_3 =$ `{python} f'{IC3:.1f}'`. From $I_{b1}$ and $IC_3$ we can get the specific current $I_{spec3} =$ `{python} f'{Ispec3/1e-9:.2f}'` $nA$ and the aspect ratio $W_3/L_3 =$ `{python} f'{WoverL3:.3f}'`. Since $W_3/L_3$ is very small, we need to set $W_3$ to the minimum width $W_3 = W_{min} =$ `{python} f'{W3/1e-9:.0f}'` $nm$ and get the length $L_3 =$ `{python} f'{L3/1e-6:.2f}'` $\mu m$.

The sizing process is now finalized. We will summarize the transistor sizes and bias currents in the next section.

## Summary
### Specifications
The specifications are recalled in @tbl-ota_specs2.

```{python}
#| label: tbl-ota_specs2
#| tbl-cap: OTA specifications.

from specs import *
from IPython.display import Markdown
from tabulate import tabulate

ota_specs_df=pd.DataFrame(
{
    "Name": ["AdcdB","GBWspec","CL","Vosmax","PMdeg"],
    "Value": [AdcdB,GBWspec,CL,Vosmax,PMdeg]
})
#pd.set_option('display.float_format', '{:.2E}'.format)
#ota_specs_df

Adc=10**(AdcdB/20)
wu=2*pi*GBWspec
table = [["Minimum DC gain","$A_{dc}$",AdcdB,"$dB$"],
         ["Minimum gain-bandwidth product","$GBW$",GBWspec/1e6,"$MHz$"],
         ["Load capacitance","$C_L$",CL/1e-12,"$pF$"],
         ["Maximum input-referred random offset voltage","$V_{os}$",Vosmax/1e-3,"$mV$"],
         ["Phase margin","$PM$",PMdeg,"$^{\\circ}$"]
         ]

Markdown(tabulate(
  table,
  headers=["Specification","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center"),
  floatfmt=".0f"
))
```

### Bias
The bias information are summarized in @tbl-ota_bias.

```{python}
#| label: tbl-ota_bias
#| tbl-cap: OTA bias.

ota_bias_df=pd.DataFrame(
{
    "Name": ["VDD","Ib1","Ib2","Cc"],
    "Value": [VDD,Ib1,Ib2,Cc]
})
#pd.set_option('display.float_format', '{:.1E}'.format)
#ota_bias_df

table = [["Supply voltage","$V_{DD}$",f'{VDD:.1f}',"$V$"],
         ["1^st^-stage bias current","$I_{b1}$",f'{Ib1/1e-9:.0f}',"$nA$"],
         ["2^nd^-stage bias current","$I_{b2}$",f'{Ib2/1e-6:.0f}',"$\\mu A$"],
         ["Compensation capacitance","$C_c$",f'{Cc/1e-12:.1f}',"$pF$"]
         ]
Markdown(tabulate(
  table,
  headers=["Bias voltage or current","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center"),
  floatfmt=".1f"
))
```


### Transistor information
The transistor sizes and large-signal variables are summarized in @tbl-transistor_info1, whereas @tbl-transistor_info2 gives the small-signal and thermal noise parameters. An Excel table is generated with more information (e.g. all the parasitic capacitances).

### Transistor information
The transistor sizes and large-signal variables are summarized in @tbl-transistor_info1, whereas @tbl-transistor_info2 gives the small-signal and thermal noise parameters. An Excel table is generated with more information (e.g. all the parasitic capacitances).

```{python}
#| label: tbl-transistor_info1
#| tbl-cap: Transistor size and bias information.

excelFilename = otaName + version + ".xlsx"

transistor_info={
    "Type": ["n","n","p","n","n","p","p","n","n"],
    "Function": ["DP","DP","CS","CM","CM","CM","CM","CM","CM"],
    "W": [W1,W1,W2,W3,W3,W4,W4,W5,W5],
    "L": [L1,L1,L2,L3,L3,L4,L4,L5,L5],
    "ID": [Ib1,Ib1,Ib2,2*Ib1,2*Ib1,Ib1,Ib1,Ib2,Ib2]
}
transistor_list=["M1a","M1b","M2","M3a","M3b","M4a","M4b","M5a","M5b"]

ota_df=pd.DataFrame(transistor_info, index=transistor_list)

ota_df["W/L"]=ota_df["W"]/ota_df["L"]
ota_df["Ispec"]=np.where(ota_df["Type"]=="n",
                                     ota_df["W/L"]*Ispecsqn,
                                     ota_df["W/L"]*Ispecsqp)
ota_df["IC"]=ota_df["ID"]/ota_df["Ispec"]
ota_df["VP-VS"]=UT*vps_ic(ota_df["IC"])
ota_df["n"]=np.where(ota_df["Type"]=="n",
                                     n0n,
                                     n0p)
ota_df["VG-VT0"]=np.where(ota_df["Type"]=="n",
                                     ota_df["VP-VS"]/n0n,
                                     ota_df["VP-VS"]/n0p)
ota_df["VDSsat"]=UT*vdssat_ic(ota_df["IC"])
ota_df["Gspec"]=ota_df["Ispec"]/UT
ota_df["Gms"]=ota_df["Gspec"]*gms_ic(ota_df["IC"])
ota_df["Gm"]=np.where(ota_df["Type"]=="n",
                                     ota_df["Gms"]/n0n,
                                     ota_df["Gms"]/n0p)
ota_df["Gds"]=np.where(ota_df["Type"]=="n",
                                     ota_df["ID"]/(lambdan*ota_df["L"]),
                                     ota_df["ID"]/(lambdap*ota_df["L"]))
ota_df["gamman"]=np.where(ota_df["Type"]=="n",
                                     gamman_ic(ota_df["IC"],n0n),
                                     gamman_ic(ota_df["IC"],n0p))
ota_df["COX"]=Cox*ota_df["W"]*ota_df["L"]
ota_df["CGSi"]=ota_df["COX"]*cgsi_ic(ota_df["IC"])
ota_df["CGDi"]=0
ota_df["CGBi"]=np.where(ota_df["Type"]=="n",
                                     ota_df["COX"]*cgbi_ic(ota_df["IC"],n0n),
                                     ota_df["COX"]*cgbi_ic(ota_df["IC"],n0p))
ota_df["CBSi"]=np.where(ota_df["Type"]=="n",
                                     ota_df["COX"]*cbsi_ic(ota_df["IC"],n0n),
                                     ota_df["COX"]*cbsi_ic(ota_df["IC"],n0p))
ota_df["CBDi"]=np.where(ota_df["Type"]=="n",
                                     ota_df["CGDi"]*(n0n-1),
                                     ota_df["CGDi"]*(n0p-1))
ota_df["CGSe"]=np.where(ota_df["Type"]=="n",
                                     ota_df["W"]*CGSOn,
                                     ota_df["W"]*CGSOp)
ota_df["CGDe"]=np.where(ota_df["Type"]=="n",
                                     ota_df["W"]*CGDOn,
                                     ota_df["W"]*CGDOp)
ota_df["CGBe"]=np.where(ota_df["Type"]=="n",
                                    ota_df["W"]*CGBOn,
                                    ota_df["W"]*CGBOp)
ota_df["CBSe"]=np.where(ota_df["Type"]=="n",
                                    ota_df["W"]*ota_df["L"]*CJn+2*(ota_df["W"]+ota_df["L"])*CJSWn,
                                    ota_df["W"]*ota_df["L"]*CJp+2*(ota_df["W"]+ota_df["L"])*CJSWp)
ota_df["CBDe"]=np.where(ota_df["Type"]=="n",
                                    ota_df["W"]*ota_df["L"]*CJn+2*(ota_df["W"]+ota_df["L"])*CJSWn,
                                    ota_df["W"]*ota_df["L"]*CJp+2*(ota_df["W"]+ota_df["L"])*CJSWp)
ota_df["CGS"]=ota_df["CGSi"]+ota_df["CGSe"]
ota_df["CGD"]=ota_df["CGDi"]+ota_df["CGDe"]
ota_df["CGB"]=ota_df["CGBi"]+ota_df["CGBe"]
ota_df["CBS"]=ota_df["CBSi"]+ota_df["CBSe"]
ota_df["CBD"]=ota_df["CBDi"]+ota_df["CBDe"]
#pd.set_option('display.float_format', '{:.2E}'.format)
#ota_df

if newDesign:
  with pd.ExcelWriter(excelFilename) as writer:
    ota_specs_df.to_excel(writer, sheet_name="Specs", index=False)
    ota_bias_df.to_excel(writer, sheet_name="Bias", index=False)
    ota_df.to_excel(writer, sheet_name="Transistors")

# Generate the table from dataframe
feature_list=["W","L","ID","Ispec","IC","VG-VT0","VDSsat"]
Nmos=len(transistor_list)
Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(ota_df.at[mos,feature])
  table.append(row)

# Scale data for proper units
for i in range(Nmos):
  for j in [1,2]:
    table[i][j]=table[i][j]/1e-6
  for j in [3,4]:
    table[i][j]=table[i][j]/1e-9
  for j in [6,7]:
    table[i][j]=table[i][j]/1e-3

Markdown(tabulate(
  table,
  headers=["Transistor","$W\\;[\\mu m]$","$L\\;[\\mu m]$","$I_D\\;[nA]$","$I_{{spec}}\\;[nA]$","$IC$","$V_G-V_{{T0}}\\;[mV]$","$V_{{DSsat}}\\;[mV]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center","center","center"),
  floatfmt=(".3f",".2f",".2f",".0f",".0f",".1f",".0f",".0f")
))
```

```{python}
#| label: tbl-transistor_info2
#| tbl-cap: Transistor small-signal and thermal noise parameters.

# Generate the table from dataframe
feature_list=["Gspec","Gms","Gm","Gds","gamman"]
Nmos=len(transistor_list)
Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(ota_df.at[mos,feature])
  table.append(row)

# Scale data for proper units
for i in range(Nmos):
  for j in [1,2,3]:
    table[i][j]=table[i][j]/1e-6
  for j in [4]:
    table[i][j]=table[i][j]/1e-9

Markdown(tabulate(
  table,
  headers=["Transistor","$G_{{spec}}\\;[\\mu A/V]$","$G_{{ms}}\\;[\\mu A/V]$","$G_m\\;[\\mu A/V]$","$G_{{ds}}\\;[nA/V]$","$\\gamma_n$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f",".3f",".3f")
))
```

# OTA Characteristics
In this section, we check whether the specs are achieved.

## Open-loop gain
We start with cheking the open-loop transfer function. The DC gains of the 1^st^- and 2^nd^-stage and the overall gain are estimated and given in @tbl-ota_dc_gain. We see that the 1^st^-stage DC gain is slightly larger than required whereas the 2^nd^-stage DC gain is right on target. This leads to a DC gain that is sligtly larger than the specifications. This is OK accounting for the fact that the DC gain is strongly depending on the output conductances for which we use a very crude model.

```{python}
#| label: tbl-ota_dc_gain
#| tbl-cap: OTA DC gains.

Gm1=ota_df.at['M1a','Gm']
Gds1=ota_df.at['M1a','Gds']
Gds4=ota_df.at['M4a','Gds']
G1=Gds1+Gds4
Gm2=ota_df.at['M2','Gm']
Gds2=ota_df.at['M2','Gds']
Gds5=ota_df.at['M5b','Gds']
G2=Gds2+Gds5
Adc1=Gm1/G1
Adc2=Gm2/G2
Adcthe=Adc1*Adc2
Adc1dB=20*log(Adc1)
Adc2dB=20*log(Adc2)
AdcdBthe=20*log(Adcthe)

table = [["1^st^-stage gain $A_{dc1}$",Adc1,Adc1dB,"-"],
         ["2^nd^-stage gain $A_{dc2}$",Adc2,Adc2dB,"-"],
         ["Overall gain $A_{dc}$",Adcthe,AdcdBthe,"-"]
         ]
Markdown(tabulate(
  table,
  headers=["Symbol","Value","Value in dB","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center"),
  floatfmt=".1f"
))
```

Plotting the open-loop transfer function also requires an estimation of the dominant pole $f_{p1}$, the non-dominant ploe $f_{p2}$ and the zero $f_z$. They depend on the estimation of the capacitance $C_1$ and $C_2$ at each node 1 and 2. They are given in @tbl-c1 and @tbl-c2. The resulting poles and zero are then given in @tbl-poles. 

```{python}
#| label: tbl-c1
#| tbl-cap: Estimation of the parasitic capacitance at node 1 $C_1$.

CGS2=ota_df.at['M2','CGS']
CGB2=ota_df.at['M2','CGB']
CBD4=ota_df.at['M4b','CBD']
CBD1=ota_df.at['M1b','CBD']
CGD1=ota_df.at['M1b','CGD']
C1=CGS2+CGB2+CBD4+CBD1+CGD1

table = [["$C_{GS2}$",CGS2/1e-15,"fF"],
         ["$C_{GB2}$",CGB2/1e-15,"fF"],
         ["$C_{BD4}$",CBD4/1e-15,"fF"],
         ["$C_{BD1}$",CBD1/1e-15,"fF"],
         ["$C_{GD1}$",CGD1/1e-15,"fF"],
         ["$C_1$",C1/1e-15,"fF"]
         ]
Markdown(tabulate(
  table,
  headers=["Symbol","Theoretical Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center"),
  floatfmt=".1f"
))
```

```{python}
#| label: tbl-c2
#| tbl-cap: Estimation of the parasitic capacitance at node 2 $C_2$.

CBD2=ota_df.at['M2','CBD']
CBD5=ota_df.at['M5b','CBD']
C2=CBD2+CBD5+CL

table = [["$C_{BD2}$",CBD2/1e-15,"fF"],
         ["$C_{BD5}$",CBD5/1e-15,"fF"],
         ["$C_L$",CL/1e-12,"pF"],
         ["$C_2$",C2/1e-12,"pF"]
         ]
Markdown(tabulate(
  table,
  headers=["Symbol","Theoretical Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center"),
  floatfmt=".3f"
))
```

```{python}
#| label: tbl-poles
#| tbl-cap: Estimation of the poles and zero.

from scipy.optimize import fsolve

def Adm(s,Adc,wz,wp1,wp2):
    num=Adc*(1-s/wz)
    den=(1+s/wp1)*(1+s/wp2)
    return num/den

def fun(f):
    jw=1j*2*pi*f
    AmagdB=20*log(abs(Adm(jw,Adcthe,wz,wp1,wp2)))
    return AmagdB

GBWest=Gm1/(2*pi*Cc)
wp1=G1*G2/(Gm2*Cc)
fp1=wp1/(2*pi)
wp2=Gm2*Cc/(Cc*C2+Cc*C1+C1*C2)
fp2=wp2/(2*pi)
wz=Gm2/Cc
fz=wz/(2*pi)
GBWguess=GBWest
GBWsol=fsolve(fun,GBWguess)
GBWthe=GBWsol[0]

table = [["$GBW$",GBWspec/1e6,"MHz","Specification"],
         ["$GBW = G_{m1}/C_c$",GBWest/1e6,"MHz","Estimation without effect of zero"],
         ["$GBW$",GBWthe/1e6,"MHz","Estimation including effect of zero"],
         ["$f_{p1}$",fp1,"Hz","Dominant pole at node 1"],
         ["$f_{p2}$",fp2/1e6,"MHz","Non-dominant pole at node 2"],
         ["$f_{p2}/GBW$",fp2/GBWest,"-","Non-dominant pole ratio"],
         ["$f_z$",fz/1e6,"MHz","Zero"],
         ["$f_z/GBW$",fz/GBWest,"-","Zero ratio"],
         ]
Markdown(tabulate(
  table,
  headers=["Symbol","Value","Unit","Comment"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","left"),
  floatfmt=".3f"
))
```

From @tbl-poles, we see that the non-dominant pole $f_{p2}$ is `{python} f'{fp2/GBWest:.1f}'` times higher than the $GBW$ which should ensure the desired phase margin $PM$. We can now plot the magnitude and phase of the open-loop gain which is shown in @fig-ota_tf_the.

```{python}
#| label: fig-ota_tf_the
#| fig-cap: "OTA theoretical transfer function."

import matplotlib.patches as mpatches
import matplotlib.ticker

Npts=101
logfmin=-1
logfmax=8
fmin=pow(10,logfmin)
fmax=pow(10,logfmax)
#x=np.linspace(xmin,xmax,Npts,endpoint=True)
fthe=np.logspace(logfmin,logfmax,Npts,endpoint=True,base=10.0)

AmagdBthe=np.zeros(Npts)
Aphiradthe=np.zeros(Npts)
Aphidegthe=np.zeros(Npts)
for k in range(0,Npts):
    jw=1j*2*pi*fthe[k]
    AmagdBthe[k]=20*log(abs(Adm(jw,Adcthe,wz,wp1,wp2)))
    Aphiradthe[k]=np.angle(Adm(jw,Adcthe,wz,wp1,wp2))

Aphidegthe=np.unwrap(Aphiradthe)*180/pi

PGBWthe=np.angle(Adm(1j*2*pi*GBWthe,Adcthe,wz,wp1,wp2),deg=True)
PMthe=180+PGBWthe

plt.style.use('plt_style_small.mplstyle')
params = {'figure.figsize': (5,5)}
plt.rcParams.update(params)

fig, axs = plt.subplots(2, sharex=True)

axs[0].semilogx([fmin,GBWthe],[0,0],'k--', linewidth=lw)
axs[0].semilogx([GBWthe,GBWthe],[0,-60],'k--', linewidth=lw)
axs[0].semilogx(fthe,AmagdBthe,'r',label='Theory')
axs[0].set(xlim=(fmin,fmax), ylim=(-60,120), ylabel='$|A_{vd}|$ [dB]')
axs[0].set_yticks([-60,-40,-20,0,20,40,60,80,100,120])
#axs[0].legend(loc='best')
textstr1 = '\n'.join((
    f'$A_{{dc}} =$ {AdcdBthe:.1f} dB',
    f'$GBW =$ {GBWthe/1e6:.3f} GHz'))
axs[0].text(0.67, 0.93, textstr1, ha='left', va='top', transform=axs[0].transAxes, size=9,
            bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogx([fmin,GBWthe],[PGBWthe,PGBWthe],'k--', linewidth=lw)
axs[1].semilogx([GBWthe,GBWthe],[PGBWthe,0],'k--', linewidth=lw)
axs[1].semilogx(fthe,Aphidegthe,'b',label='Theory')
axs[1].set(ylim=(-180,0), xlabel='Frequency [Hz]', ylabel='$arg\\{A_{vd}\\}$ [deg]')
axs[1].set_xticks([1e-1,1e0,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
axs[1].set_yticks([-180,-135,-90,-45,0])
#axs[1].legend(loc='best')
arrow = mpatches.FancyArrowPatch((GBWthe, PGBWthe), (GBWthe, -180),
                                 arrowstyle='<|-|>', color="black", mutation_scale=9)
axs[1].add_patch(arrow)
axs[1].annotate(f'Phase margin = {PMthe:.0f}$^{{\\circ}}$ ', (0, 0.5), xycoords=arrow, ha='right', va='center', size=9)
plt.subplots_adjust(hspace=0.1)

plt.show()
```

From @fig-ota_tf_the, we see that the specifications on the DC gain, gain-bandwidth product and phase margin are all met.

## Input-referred noise
We can also estimate the input-referred noise PSD. We start by evaluating the input-referred themal noise PSD $S_{ninth}$ and resistance $R_{nth}$. To this purpose we calculate all the parameters that are needed for computing $S_{ninth}$ which are given in @tbl-thermal.

```{python}
#| label: tbl-thermal
#| tbl-cap: OTA thermal noise parameters.

Gm1=ota_df.at['M1a','Gm']
Gds1=ota_df.at['M1a','Gds']
Gds4=ota_df.at['M4a','Gds']
G1=Gds1+Gds4
Gm2=ota_df.at['M2','Gm']
Gm4=ota_df.at['M4a','Gm']
Gm5=ota_df.at['M5a','Gm']
gamman1=ota_df.at['M1a','gamman']
gamman2=ota_df.at['M2','gamman']
gamman4=ota_df.at['M4a','gamman']
gamman5=ota_df.at['M5a','gamman']
etath=gamman4/gamman1*Gm4/Gm1+G1**2/(2*Gm1*Gm2)*(gamman2/gamman1+2*gamman5/gamman1*Gm5/Gm2)
gammanotathe=2*gamman1*(1+etath)
Rninththe=2*gamman1/Gm1*(1+etath)
Sninththe=4*kT*Rninththe
SninthdBvthe=10*log(Sninththe)

table = [["$G_{m1}$",Gm1/1e-6,"$\\frac{\\mu A}{V}$"],
         ["$G_{m2}$",Gm2/1e-6,"$\\frac{\\mu A}{V}$"],
         ["$G_{m4}$",Gm4/1e-9,"$\\frac{nA}{V}$"],
         ["$G_{m5}$",Gm1/1e-6,"$\\frac{\\mu A}{V}$"],
         ["$G_{m1}/G_{m4}$",Gm1/Gm4,"-"],
         ["$G_{m2}/G_{m5}$",Gm2/Gm5,"-"],
         ["$2 G_{m1} G_{m2}/G_1^2$",2*Gm1*Gm2/G1**2,"-"],
         ["$\\gamma_{n1}$",gamman1,"-"],
         ["$\\gamma_{n2}$",gamman2,"-"],
         ["$\\gamma_{n4}$",gamman4,"-"],
         ["$\\gamma_{n5}$",gamman5,"-"],
         ["$\\eta_{th}$",etath,"-"],
         ["$2\\gamma_{n1}$",2*gamman1,"-"],
         ["$\\gamma_{n,ota}$",gammanotathe,"-"],
         ["$R_{nth}$",Rninththe/1e3,"$k \\Omega$"],
         ["$\\sqrt{S_{ninth}}$",sqrt(Sninththe)/1e-9,"$\\frac{nV}{\\sqrt{Hz}}$"],
         ["$10 \\cdot \\log(S_{ninth})$",SninthdBvthe,"$\\frac{dBv}{\\sqrt{Hz}}$"]
         ]

Markdown(tabulate(
  table,
  headers=["Symbol","Theoretical Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center"),
  floatfmt=".3f"
))
```

From @tbl-thermal, we see that M~4a~-M~4b~, M~2~ and M~5a~-M~5b~ only contribute `{python} f'{100*(etath):.0f}'` % of the total input-referred thermal noise. This leads to an OTA thermal noise excess factor that is only  `{python} f'{100*(gammanotathe/(2*gamman1)-1):.0f}'` % larger than the minimum `{python} f'{2*gamman1:.1f}'` contributed by the differential pair M~1a~-M~1b~ only.

We can also calculate all the parameters required to compute the flicker noise. They are given in @tbl-flicker.

```{python}
#| label: tbl-flicker
#| tbl-cap: OTA flicker noise parameters.

W1=ota_df.at['M1a','W']
L1=ota_df.at['M1a','L']
W2=ota_df.at['M2','W']
L2=ota_df.at['M2','L']
W4=ota_df.at['M4a','W']
L4=ota_df.at['M4a','L']
W5=ota_df.at['M5b','W']
L5=ota_df.at['M5b','L']
etafl=(Gm4/Gm1)**2*rhop/rhon*W1*L1/(W4*L4)+1/2*(G1/Gm1)**2*(rhop/rhon*W1*L1/(W2*L2)+2*(Gm5/Gm2)**2*W1*L1/(W5*L5))
fkthe=2*rhon/(W1*L1*Rninththe)*(1+etafl)

table = [["$(G_{m1}/G_{m4})^2$",(Gm1/Gm4)**2,"-"],
         ["$(G_{m1}/G_1)^2$",(Gm1/G1)**2,"-"],
         ["$(G_{m2}/G_{m5})^2$",(Gm2/Gm5)**2,"-"],
         ["$\\frac{W_1 \\cdot L_1}{W_4 \\cdot L_4}$",W1*L1/(W4*L4),"-"],
         ["$\\frac{W_1 \\cdot L_1}{W_2 \\cdot L_2}$",W1*L1/(W2*L2),"-"],
         ["$\\frac{W_1 \\cdot L_1}{W_5 \\cdot L_5}$",W1*L1/(W5*L5),"-"],
         ["$\\eta_{fl}$",etafl,"-"],
         ["$f_k$",fkthe/1e3,"$kHz$"]
         ]

Markdown(tabulate(
  table,
  headers=["Symbol","Theoretical Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center"),
  floatfmt=".3f"
))
```

From @tbl-flicker, we see that $\eta-{fl} =$ `{python} f'{etath:.1f}'`, which means that the input-referred flicker noise PSD is dominated by M~4a~-M~4b~, M~2~ and M~5a~-M~5b~. From From @tbl-flicker,  we can actually identify that the dominant contribtuion to the input-referred flicker noise PSD is due to M~4a~-M~4b~. As discussed when sizing M~4a~-M~4b~, we could increase the area of M~4a~-M~4b~ but at the cost of more paraisitc capacitance at the node 4 and hence les phase margin, which is undesirable. The corner frequency is actually quite low at $f_k =$ `{python} f'{fkthe/1e3:.1f}'` kHz. The input-referred noise PSD is plotted in @fig-ota_noise_the.

```{python}
#| label: fig-ota_noise_the
#| fig-cap: "OTA theoretical input-referred noise PSD."

def Snflicker(f,S0,fk):
    return(S0*fk/f)

def Sntot(f,S0,fk):
    return(S0*(1+fk/f))

Npts=101
logfminnz=0
logfmaxnz=8
fminnz=pow(10,logfminnz)
fmaxnz=pow(10,logfmaxnz)
fthenz=np.logspace(logfminnz,logfmaxnz,Npts,endpoint=True,base=10.0)

S0=4*kT*Rninththe
S0dBvthe=10*log(S0)

Sninththe=np.zeros(Npts)
Sninflthe=np.zeros(Npts)
Sninthe=np.zeros(Npts)
SninthdBvthe=np.zeros(Npts)
SninfldBvthe=np.zeros(Npts)
SnindBvthe=np.zeros(Npts)

for k in range(0,Npts):
    Sninththe[k]=S0
    Sninflthe[k]=Snflicker(fthenz[k],S0,fkthe)
    Sninthe[k]=Sntot(fthenz[k],S0,fkthe)
    SninthdBvthe[k]=10*log(Sninththe[k])
    SninfldBvthe[k]=10*log(Sninflthe[k])
    SnindBvthe[k]=10*log(Sninthe[k])

plt.style.use('plt_style_small.mplstyle')
#plt.semilogx([fmin,fkthe],[S0dBvthe,S0dBvthe],'k--',linewidth=lw)
plt.semilogx([fkthe,fkthe],[-150,S0dBvthe],'k--',linewidth=lw)
plt.semilogx(fthenz,SninthdBvthe,'b--',label='Thermal')
plt.semilogx(fthenz,SninfldBvthe,'g--',label='Flicker')
plt.semilogx(fthenz,SnindBvthe,'r',label='Total')
plt.xlim(fminnz,fmaxnz)
plt.xticks([1e0,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-150,-90)
#plt.yticks(np.arange(-150,-110,10))
plt.ylabel('Input Noise PSD $[dBv/\\sqrt{Hz}]$')
plt.legend(loc='center right', fontsize=9)
textstr = '\n'.join((
    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$',
    f'$f_k =${fkthe/1e3:.1f} kHz'))
plt.text(0.5, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

## Input-referred random offset voltage
We have seen that the input-referred offset voltage is given by
\begin{equation}
  \sigma_{V_{os}}^2 = \sigma_{V_T}^2 + \sigma_{\beta}^2
\end{equation}
where
\begin{equation}
  \sigma_{V_T}^2 = \sigma_{V_{T1}}^2 \cdot (1 + \xi_{V_T})
\end{equation}
and
\begin{equation}
  \sigma_{\beta}^2 = \left(\frac{I_b}{G_{m1}}\right)^2 \cdot \sigma_{\beta_1}^2 \cdot (1 + \xi_{\beta}).
\end{equation}
$\xi_{V_T}$ represents the $V_T$-mismatch contributions to the input-referred offset of the current mirror relative to that of the differential pair
\begin{equation}
  \xi_{V_T} = \left(\frac{G_{m4}}{G_{m1}}\right)^2 \cdot \left(\frac{A_{VTp}}{A_{VTn}}\right)^2 \cdot \frac{W_1 L_1}{W_4 L_4}
\end{equation}
and $\xi_{\beta}$ represents the $\beta$-mismatch contributions to the input-referred offset of the current mirror relative to that of the differential pair
\begin{equation}
  \xi_{\beta} = \left(\frac{A_{\beta p}}{A_{\beta n}}\right)^2 \cdot \frac{W_1 L_1}{W_4 L_4}.
\end{equation}
The various parameters used to calculate the input-referred offset voltage are given in

```{python}
#| label: tbl-offset
#| tbl-cap: OTA input-referred offset parameters.

W1=ota_df.at['M1a','W']
L1=ota_df.at['M1a','L']
W4=ota_df.at['M4a','W']
L4=ota_df.at['M4a','L']
Gm1=ota_df.at['M1a','Gm']
Gm4=ota_df.at['M4a','Gm']
sigma2vt1=AVTn**2/(W1*L1)
sigmavt1=sqrt(sigma2vt1)
sigma2beta1=Abetan**2/(W1*L1)
sigmabeta1=sqrt(sigma2beta1)
sigma2vt4=AVTp**2/(W4*L4)
sigmavt4=sqrt(sigma2vt4)
sigma2beta4=Abetap**2/(W4*L4)
sigmabeta4=sqrt(sigma2beta4)
xivt=(Gm4/Gm1)**2*(AVTp/AVTn)**2*W1*L1/(W4*L4)
xibeta=(Abetap/Abetan)**2*W1*L1/(W4*L4)
sigma2vt=sigma2vt1*(1+xivt)
sigmavt=sqrt(sigma2vt)
sigma2beta=(Ib1/Gm1)**2*sigma2beta1*(1+xibeta)
sigmabeta=sqrt(sigma2beta)
sigma2Vos=sigma2vt+sigma2beta
sigmaVos=sqrt(sigma2Vos)

table = [["$\\sigma_{VT1}$",sigmavt1/1e-3,"$mV$","$V_T$-mismatch of M~1a~-M~1b~"],
         ["$\\sigma_{VT4}$",sigmavt4/1e-3,"$mV$","$V_T$-mismatch of M~4a~-M~4b~"],
         ["$\\xi_{V_T}$",xivt,"-","Input-referred $V_T$-mismatch of M~4a~-M~4b~ relative to M~1a~-M~1b~"],
         ["$\\sigma_{\\beta1}$",100*sigmabeta1,"$\\%$","$\\beta$-mismatch of M~1a~-M~1b~"],
         ["$\\sigma_{\\beta4}$",100*sigmabeta4,"$\\%$","$\\beta$-mismatch of M~4a~-M~4b~"],
         ["$\\xi_{\\beta}$",xibeta,"-","Input-referred $\\beta$-mismatch of M~4a~-M~4b~ relative to M~1a~-M~1b~"],
         ["$\\sigma_{V_T}$",sigmavt/1e-3,"$mV$","Total input-referred $V_T$-mismatch"],
         ["$\\sigma_{\\beta}$",sigmabeta/1e-3,"$mV$","Total input-referred $\\beta$-mismatch"],
         ["$\\sigma_{{Vos}}$",sigmaVos/1e-3,"$mV$","Total input-referred offset voltage"]
         ]

Markdown(tabulate(
  table,
  headers=["Symbol","Theoretical Value","Unit","Comment"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","left"),
  floatfmt=".3f"
))
```

The various parameters needed to compute the input-referred random offset voltage standard deviation are given in @tbl-offset. For the same reason discussed for the flicker noise, the current mirror M~4a~-M~4b~ is contributing `{python} f'{xivt:.3f}'` times more than the differential pair M~1a~-M~1b~ to the $V_T$-mismatch and `{python} f'{xibeta:.1f}'` times more than the differential pair M~1a~-M~1b~ to the $\beta$-mismatch.

## Power consumption

```{python}
Itot=2*Ib1+Ib2
P=VDD*Itot
Itele=0.5e-6
```

The total current consumption, without the current flowing in M~3a~ and M~5a~, is given by $I_{tot} =$ `{python} f'{Itot/1e-6:.2f}'` $\mu A$, resulting in a total power consumption $P =$ `{python} f'{P/1e-6:.3f}'` $\mu W$.

We can compare the current and power consumption of the Miller OTA to the telescopic OTA which offers the lowest power consumption for similar $GBW$ and DC gain specifications. The current consumption of the telescopic OTA for the actual specifications can be estimated to $I_{tot,telescopic} \cong$ `{python} f'{Itele/1e-6:.1f}'` $\mu A$. The current and power consumption of the Miller OTA is `{python} f'{Itot/Itele:.2f}'` times larger than that of the telescopic OTA for the same specifications and performance.

# Simulation results from ngspice
The theoretical results can be validated with the results obtained from simulations performed with ngspice. In order to run the simulations you need to have ngspice correctly installed. Please refer to the installation instructions.

::: {.callout-note}
The simulations are performed with ngspice @bib:ngspice:2024 using the EKV 2.6 compact model @bib:ekv2p6:doc:rev2:1998 @bib:enz:aicspj:july:1995 @bib:enz:book:2006. For ngspice, we use the original Verilog-A implementation of EKV 2.6 @bib:grabinski:ekv2p6veriloga:essderc:2019 modified by C. Enz to get the operating point informations and available on the Gitub va-models site provided by D. Warning at @bib:github:ekv26:va:2025 @bib:dwarning:2024. The Verilog-A code was then compiled with OpenVAF @bib:openvaf:2025 to generate the OSDI for running it with ngspice. The parameters correspond to a generic 180 nm bulk CMOS process @bib:grabinski:ekv2p6_param_extraction:mixdes:2015.
:::

## Operating point
We first write the parameter file for this specific design for running the ngspice simulations.
Before running the AC and NOISE simulations, we first need to check the quiescent voltages and currents and the operating points of all transistors by running a .OP simulation.

```{python}
#| label: tbl-ng_openloop_voltages1
#| tbl-cap: OTA node voltages with the OTA in open-loop without offset correction.

simtype = ".op"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationVoltages = simulationPath + fileName + ".ic"
simulationData = simulationPath + fileName + ".dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + "1.ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + "1.dat"

W1=ota_df.at['M1a','W']
L1=ota_df.at['M1a','L']
W2=ota_df.at['M2','W']
L2=ota_df.at['M2','L']
W3=ota_df.at['M3a','W']
L3=ota_df.at['M3a','L']
W4=ota_df.at['M4a','W']
L4=ota_df.at['M4a','L']
W5=ota_df.at['M5a','W']
L5=ota_df.at['M5a','L']

Vic=0.9
Vos=0

if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Ib1={Ib1/1e-9:.0f}n Ib2={Ib2/1e-6:.1f}u',
    f'.param CL={CL/1e-12:.0f}p Cc={Cc/1e-12:.1f}p',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u',
    f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u',
    f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u',
    f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u',
    f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u'
    ))
  #print(paramstr)
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  #print('Starting ngspice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)
  shutil.copy2(simulationData, ngspiceDataFile)

nodeList=["vdd","inp","inn","out","ic","id","1","3","4","5","6"]
v_df=pd.DataFrame(index=nodeList)
Nnodes=len(nodeList)
for k in range(0,Nnodes):
  nodeName=nodeList[k]
  regexp = re.compile(r'v\(' + nodeName + r'\)' + refloat)
  with open(ngspiceNodeVoltageFile) as f:
    for line in f:
      match = re.search(regexp, line)
      if match:
        v_df.at[nodeName, 'Voltage']=float(match.group(1))

Voutq=v_df.loc['out','Voltage']
#pd.set_option('display.float_format', '{:.2f}'.format)
#v_df

Markdown( 
  tabulate(v_df,
  showindex=True,
  headers=["Node","Voltage"],
  numalign="center",
  stralign="center",
  colalign=("center","center")
))
```

We can extract the OTA quiescent node voltages from the .ic file. They are presented in @tbl-ng_openloop_voltages1. As expected, we see that the output voltage $V_{outq} =$ `{python} f'{Voutq:.3f}'` $V$ is saturated to $V_{DD}$ pushing M~2~ in the linear region. This is due to the fact that M~2~ is biased in moderate inversion with a source-to-gate voltage $V_{SG2}$ about equal to $V_{T0p}$. However, for a zero differential input voltage, the voltage at node 1 is actually set to the same value than the voltage at node 4 which is equal to the $V_{SG4}$ voltage of M~4~. This voltage is larger than $V_{T0p}$ by its overdrive voltage $V_{BG4}-V_{T0p}$ because M~4a~-M~4b~ are biased in strong inversion. The only way for M~2~ to carry the current it would carry in moderate inversion if it was biased in saturation is to reduce its $V_{SD}$ voltage and therefore drive M~2~ in the linear region with a $V_{SD}$ voltage almost equal to zero. For this reason, the output voltage is saturating to $V_{DD}$. We therefore cannot simulate the open-loop transfer function because the operating points, in particular that of M~2~, are wrong.

Simulating the open-loop gain for high gain amplifiers is not easy to perform without closing the loop. There are basically two approaches to simulate the open-loop gain for high-gain amplifiers:

1) Imposing a DC offset voltage to the amplifier in open-loop configuration that brings the output voltage back to the high gain region (for example equal to the input common-mode voltage) or
2) Simulating the closed-loop gain (for example in voltage follower mode with a feedback gain of 1 and extracting the open-loop gain from the closed loop gain according to
\begin{equation}
  A_{ol}(\omega)= \frac{A_{cl}(\omega)}{1 - A_{cl}(\omega)},
\end{equation}
where $A_{cl}(\omega)$ is the simulated closed-loop transfer function and $A_{ol}(\omega)$, the computed open-loop transfer function. The above relation assumes that the open-loop DC gain is large enough for the input-referred offset voltage to be ignored.

The input-referred offset voltage can be extracted from the closed-loop voltage follower circuit as
\begin{equation}
  V_{os} = V_{in} - \left(1+\frac{1}{A}\right) \cdot V_{out} \cong V_{in} - V_{out} \quad \textsf{for $A \gg 1$},
\end{equation}
where $A \triangleq A_{ol}(0)$ is the open-loop DC gain which can be assumed to be much larger than 1. This means that, provided the DC open-loop gain is sufficiently large, the offset voltage can be measured at the amplifier differential input after imposing the proper input common-mode voltage $V_{ic}$.

We can now simulate the OTA in closed-loop as a voltage follower.

```{python}
#| label: tbl-ng_closedloop_voltages
#| tbl-cap: OTA node voltages with the OTA in voltage follower configuration.

simtype = ".op"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationVoltages = simulationPath + fileName + ".ic"
simulationData = simulationPath + fileName + ".dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + ".ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + ".dat"

if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Vic={Vic:.1f} Ib1={Ib1/1e-9:.0f}n Ib2={Ib2/1e-6:.1f}u',
    f'.param CL={CL/1e-12:.0f}p Cc={Cc/1e-12:.1f}p',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u',
    f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u',
    f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u',
    f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u',
    f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u'
    ))
  #print(paramstr)
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  #print('Starting ngspice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)
  shutil.copy2(simulationData, ngspiceDataFile)

nodeList=["vdd","inp","out","1","3","4","5","6"]
v_df=pd.DataFrame(index=nodeList)

Nnodes=len(nodeList)
for k in range(0,Nnodes):
  nodeName=nodeList[k]
  regexp = re.compile(r'v\(' + nodeName + r'\)' + refloat)
  with open(ngspiceNodeVoltageFile) as f:
    for line in f:
      match = re.search(regexp, line)
      if match:
        v_df.at[nodeName, 'Voltage']=float(match.group(1))

Voutq=v_df.loc['out','Voltage']
Vos=v_df.loc['inp','Voltage']-v_df.loc['out','Voltage']
#pd.set_option('display.float_format', '{:.6f}'.format)
#v_df
#Vos=-4.875e-3

Markdown( 
  tabulate(v_df,
  showindex=True,
  headers=["Node","Voltage"],
  numalign="center",
  stralign="center",
  colalign=("center","center")
))
```

From the node voltages of the OTA in voltage follower configuration shown in @tbl-ng_closedloop_voltages, we see that now the ouput voltage $V_{outq} =$ `{python} f'{Voutq/1e-3:.0f}'` $mV$ is very close to the input voltage that has been set to $V_{ic} =$ `{python} f'{Vic/1e-3:.0f}'` $mV$. We can then extract the corresponding offset voltage $V_{os} \cong V_{in} - V_{out} =$ `{python} f'{Vos/1e-3:.3f}'` $mV$.

We can now apply this offset voltage to the open-loop circuit for simulating the operating point.

```{python}
#| label: tbl-ng_openloop_voltages2
#| tbl-cap: OTA node voltages with the OTA in open-loop including offset correction.

from IPython.display import Markdown
from tabulate import tabulate

simtype = ".op"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationVoltages = simulationPath + fileName + ".ic"
simulationData = simulationPath + fileName + ".dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + "2.ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + "2.dat"

if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Ib1={Ib1/1e-9:.0f}n Ib2={Ib2/1e-6:.1f}u',
    f'.param CL={CL/1e-12:.0f}p Cc={Cc/1e-12:.1f}p',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u',
    f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u',
    f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u',
    f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u',
    f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u'
    ))
  #print(paramstr)
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  #print('Starting ngspice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)
  shutil.copy2(simulationData, ngspiceDataFile)

nodeList=["vdd","inp","inn","out","ic","id","1","3","4","5","6"]
v_df=pd.DataFrame(index=nodeList)

Nnodes=len(nodeList)
for k in range(0,Nnodes):
  nodeName=nodeList[k]
  regexp = re.compile(r'v\(' + nodeName + r'\)' + refloat)
  with open(ngspiceNodeVoltageFile) as f:
    for line in f:
      match = re.search(regexp, line)
      if match:
        v_df.at[nodeName, 'Voltage']=float(match.group(1))

Voutq=v_df.loc['out','Voltage']
#pd.set_option('display.float_format', '{:.6f}'.format)
#v_df

Markdown( 
  tabulate(v_df,
  showindex=True,
  headers=["Node","Voltage"],
  numalign="center",
  stralign="center",
  colalign=("center","center")
))
```

From the node voltages of the OTA in open-loop configuration shown in @tbl-ng_openloop_voltages2 after adding the offset voltage at the input, we see that now the ouput voltage $V_{outq} =$ `{python} f'{Voutq/1e-3:.0f}'` $mV$ of the open-loop circuit is sufficiently close to the common-mode input voltage $V_{ic} =$ `{python} f'{Vic/1e-3:.0f}'` $mV$.

The operating point information for all transistors are extracted from the ngspice .op file. The data is split into the large-signal operating point informations in @tbl-ng_op1, the small-signal operating point informations in @tbl-ng_op2 and the noise operating point informations in @tbl-ng_op3.

We can compare the results of the .op file (for example the inversion coefficient $IC$) to the results of the design given in @tbl-transistor_info1. We observe that the values are close.

Similarly we can compare the small-signal parameters (for example the gate transconductance $G_m$) resulting from the .op file to the results of the design presented in @tbl-transistor_info2. Again, we see that they are reasonably close.

```{python}
#| label: tbl-ng_op1
#| tbl-cap: Operating point information extracted from ngspice .op file for each transistor.

df_mos=pd.read_table(ngspiceDataFile, sep=r'\s+', skiprows=[2,4,6,8,10,12,14,16,18,20,22], dtype=np.float64, engine='python')
df_mos=df_mos.rename(columns={'@n1a[id]': 'Transistor', '@N1a[Id]': 'ID', '@N1a[Ispec]': 'Ispec', '@N1a[IC]': 'IC', '@N1a[n0]': 'n', '@N1a[Vdsat]': 'VDsat',
                              '@N1a[gm]': 'Gm', '@N1a[gms]': 'Gms', '@N1a[gds]': 'Gds', '@N1a[gmbs]': 'Gmb',
                              '@N1a[Rn]': 'Rn', '@N1a[Vnth]': 'Vnth', '@N1a[gamman]': 'gamman', '@N1a[Vnfl]': 'Vnfl at 1Hz'})
df_mos['Transistor'] = df_mos['Transistor'].astype(str)

for k in range(Nmos):
  df_mos.at[k, 'Transistor'] = transistor_list[k]

df_mos.set_index('Transistor', inplace=True)
df_mos.rename_axis(index=None, inplace=True)
pd.set_option('display.float_format', '{:.2E}'.format)
#df_mos

feature_list=["ID","Ispec","IC","n","VDsat"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mos.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [1,2]:
    table[i][j]=table[i][j]/1e-9
  for j in [5]:
    table[i][j]=table[i][j]/1e-3

Markdown(tabulate(
  table,
  headers=["Transistor","$I_D\\;[nA]$","$I_{spec}\\;[nA]$","$IC$ [-]","$n$ [-]","$V_{DSsat}\\;[mV]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center"),
  floatfmt=(".3f",".1f",".1f",".3f",".2f",".0f")
))
```

```{python}
#| label: tbl-ng_op2
#| tbl-cap: Small-signal operating point information extracted from ngspice .op file for each transistor.

feature_list=["Gm","Gms","Gds"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mos.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [1,2]:
    table[i][j]=table[i][j]/1e-6
  for j in [3]:
    table[i][j]=table[i][j]/1e-9

Markdown(tabulate(
  table,
  headers=["Transistor","$G_m\\;[\\mu A/V]$","$G_{ms}\\;[\\mu A/V]$","$G_{ds}\\;[nA/V]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f")
))
```

```{python}
#| label: tbl-ng_op3
#| tbl-cap: Noise operating point information extracted from ngspice .op file for each transistor.

feature_list=["Rn","Vnth","gamman","Vnfl at 1Hz"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mos.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [1]:
    table[i][j]=table[i][j]/1e3
  for j in [2,4]:
    table[i][j]=table[i][j]/1e-9

Markdown(tabulate(
  table,
  headers=["Transistor","$R_n\\;[k\\Omega]$","$\\sqrt{S_{ID,th}}\\;[nA/\\sqrt{Hz}]$","$\\gamma_n$ [-]","$\\sqrt{S_{ID,fl}}$ at 1Hz $[nA/\\sqrt{Hz}]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f")
))
```

We can also check the bias voltages and operating region of each transistor which are given in @tbl-ng_bias.

```{python}
#| label: tbl-ng_bias
#| tbl-cap: Bias voltages and operating regions extracted from ngspice for each transistor.

VGB1a=v_df.loc['inp','Voltage']
VGB1b=v_df.loc['inn','Voltage']
VBG2=v_df.loc['vdd','Voltage']-v_df.loc['1','Voltage']
VGB3a=v_df.loc['5','Voltage']
VGB3b=v_df.loc['5','Voltage']
VBG4a=v_df.loc['vdd','Voltage']-v_df.loc['4','Voltage']
VBG4b=v_df.loc['vdd','Voltage']-v_df.loc['4','Voltage']
VGB5a=v_df.loc['6','Voltage']
VGB5b=v_df.loc['6','Voltage']

VSB1a=v_df.loc['3','Voltage']
VSB1b=v_df.loc['3','Voltage']
VBS2=0
VSB3a=0
VSB3b=0
VBS4a=0
VBS4b=0
VSB5a=0
VSB5b=0

VDB1a=v_df.loc['4','Voltage']
VDB1b=v_df.loc['1','Voltage']
VBD2=v_df.loc['vdd','Voltage']-v_df.loc['out','Voltage']
VDB3a=v_df.loc['5','Voltage']
VDB3b=v_df.loc['3','Voltage']
VBD4a=v_df.loc['vdd','Voltage']-v_df.loc['4','Voltage']
VBD4b=v_df.loc['vdd','Voltage']-v_df.loc['1','Voltage']
VDB5a=v_df.loc['6','Voltage']
VDB5b=v_df.loc['out','Voltage']

VDS1a=VDB1a-VSB1a
VDS1b=VDB1b-VSB1b
VSD2=VBD2-VBS2
VDS3a=VDB3a-VSB3a
VDS3b=VDB3b-VSB3b
VSD4a=VBD4a-VBS4a
VSD4b=VBD4b-VBS4b
VDS5a=VDB5a-VSB5a
VDS5b=VDB5b-VSB5b

ID1a=df_mos.loc['M1a','ID']
ID1b=df_mos.loc['M1b','ID']
ID2=df_mos.loc['M2','ID']
ID3a=df_mos.loc['M3a','ID']
ID3b=df_mos.loc['M3b','ID']
ID4a=df_mos.loc['M4a','ID']
ID4b=df_mos.loc['M4b','ID']
ID5a=df_mos.loc['M5a','ID']
ID5b=df_mos.loc['M5b','ID']

IC1a=df_mos.loc['M1a','IC']
IC1b=df_mos.loc['M1b','IC']
IC2=df_mos.loc['M2','IC']
IC3a=df_mos.loc['M3a','IC']
IC3b=df_mos.loc['M3b','IC']
IC4a=df_mos.loc['M4a','IC']
IC4b=df_mos.loc['M4b','IC']
IC5a=df_mos.loc['M5a','IC']
IC5b=df_mos.loc['M5b','IC']

VDsat1a=df_mos.loc['M1a','VDsat']
VDsat1b=df_mos.loc['M1b','VDsat']
VDsat2=df_mos.loc['M2','VDsat']
VDsat3a=df_mos.loc['M3a','VDsat']
VDsat3b=df_mos.loc['M3b','VDsat']
VDsat4a=df_mos.loc['M4a','VDsat']
VDsat4b=df_mos.loc['M4b','VDsat']
VDsat5a=df_mos.loc['M5a','VDsat']
VDsat5b=df_mos.loc['M5b','VDsat']

df_mosop={
  "Type": ["n","n","p","n","n","p","p","n","n"],
  "Function": ["DP","DP","CS","CM","CM","CM","CM","CM","CM"],
  "ID": [ID1a,ID1b,ID2,ID3a,ID3b,ID4a,ID4b,ID5a,ID5b],
  "IC": [IC1a,IC1b,IC2,IC3a,IC3b,IC4a,IC4b,IC5a,IC5b],
  "VG": [VGB1a,VGB1b,VBG2,VGB3a,VGB3b,VBG4a,VBG4b,VGB5a,VGB5b],
  "VS": [VSB1a,VSB1b,VBS2,VSB3a,VSB3b,VBS4a,VBS4b,VSB5a,VSB5b],
  "VD": [VDB1a,VDB1b,VBD2,VDB3a,VDB3b,VBD4a,VBD4b,VDB5a,VDB5b],
  "VDS": [VDS1a,VDS1b,VSD2,VDS3a,VDS3b,VSD4a,VSD4b,VDS5a,VDS5b],
  "VDsat": [VDsat1a,VDsat1b,VDsat2,VDsat3a,VDsat3b,VDsat4a,VDsat4b,VDsat5a,VDsat5b]
  }

df_mosop=pd.DataFrame(df_mosop, index=transistor_list)
df_mosop["Region"]=np.where(df_mosop["IC"]<0.1,
                                     "WI",
                                     np.where(df_mosop["IC"]<10,
                                     "MI",
                                     "SI"))
df_mosop["Saturation"]=np.where(df_mosop["VDS"]>df_mosop["VDsat"],
                                     "sat",
                                     "lin")
#pd.set_option('display.float_format', '{:.3E}'.format)
#df_mosop

feature_list=["Type","Function","VG","VS","VD","VDS","VDsat","Region","Saturation"]
#Nmos=len(transistor_list)
Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(df_mosop.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [6,7]:
    table[i][j]=table[i][j]/1e-3

Markdown(tabulate(
  table,
  headers=["Trans.","Type","Funct.","$V_G\\;[V]$","$V_S\\;[V]$","$V_D\\;[V]$","$V_{DS}\\;[mV]$","$V_{DSsat}\\;[mV]$","Reg.","Sat."],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center","center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f",".3f",".3f",".0f",".0f",".3f",".3f")
))
```

From @tbl-ng_bias, we see that all transistors are biased in saturation. The operating points look fine. We can now proceed with the simulation of the open-loop large-signal transfer characteristic.


## Large-signal differential transfer characteristic
We now simulate the DC differential transfer characteristic. We can then check the systematic offset voltage that was extracted above. The simulation of the large-signal input-output characteristic is presented in @fig-ng_large_signal.

```{python}
#| label: fig-ng_large_signal
#| fig-cap: "Simulated large-signal input-output characteristic."

simtype = ".dc"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + "1.dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + "1.log"

Vidmin=-0.45e-3
Vidmax=-0.442e-3
Npts=1001
dVid=(Vidmax-Vidmin)/(Npts-1)

if newSim:
  simpar = '\n'.join((
    f'.csparam Vidmin={Vidmin:.3e}',
    f'.csparam Vidmax={Vidmax:.3e}',
    f'.csparam dVid={dVid:.3e}'
  ))
  simparFile = simulationPath + "simulation.dc.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

Vidsim=df_sim['v-sweep'].to_numpy()
Voutsim=df_sim['Vout'].to_numpy()

regexp = re.compile(r'voutmax' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutmax=float(match.group(1))

regexp = re.compile(r'voutmin' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutmin=float(match.group(1))

regexp = re.compile(r'vos' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Vos=float(match.group(1))

Voutq=0.9
Voutmax=1.5
Voutmin=0.4
Vswing=Voutmax-Voutmin

plt.plot([Vidmin/1e-3,Vos/1e-3],[Voutq,Voutq],'k--', linewidth=lw)
plt.plot([Vos/1e-3,Vos/1e-3],[0,Voutq],'k--', linewidth=lw)
plt.plot([Vidmin/1e-3,Vidmax/1e-3],[Voutmax,Voutmax],'k--', linewidth=lw)
plt.plot([Vidmin/1e-3,Vidmax/1e-3],[Voutmin,Voutmin],'k--', linewidth=lw)
plt.plot(Vidsim/1e-3,Voutsim,'r')
plt.xlim(Vidmin/1e-3,Vidmax/1e-3)
#plt.xticks(np.arange(-5.8,-4,0.2))
plt.xlabel('$V_{id}$ [$mV$]')
plt.ylim(0,1.8)
plt.yticks(np.arange(0,2,0.2))
plt.ylabel('$V_{out}$ [V]')
#plt.legend(loc='best')
textstr = '\n'.join((
  f'$V_{{DD}} =$ {VDD:.1f} V',
  f'$V_{{ic}} =$ {Vic:.3f} V',
  f'$V_{{outq}} =$ {Voutq:.3f} V',
  f'$V_{{os}} =$ {Vos/1e-6:.1f} $\\mu V$',
  f'$V_{{outmax}} =$ {Voutmax:.3f} V',
  f'$V_{{outmin}} =$ {Voutmin:.3f} V',
  f'$V_{{swing}} =$ {Vswing:.2f} V'))
plt.text(1.05, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

From @fig-ng_large_signal, we see that the output swing is about $V_{out,swing} =$ `{python} f'{Vswing:.1f}'` $V$. We can now zoom into the high gain region in order to extract the offset voltage that is needed to bring the output voltage back to $V_{outq} =$ `{python} f'{Voutq:.3f}'` $V$. The simulation results are presented in @fig-ng_large_signal_zoom.

```{python}
#| label: fig-ng_large_signal_zoom
#| fig-cap: "Zoom of the simulated large-signal input-output characteristic in the high gain region."

simtype = ".dc"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + "2.dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + "2.log"

Vidmin=-446.5e-6
Vidmax=-445.5e-6
#Vidmin=round(1e5*Vos)/1e5-1e-5
#Vidmax=Vidmin+2e-5
Npts=1001
dVid=(Vidmax-Vidmin)/(Npts-1)

if newSim:
  simpar = '\n'.join((
    f'.csparam Vidmin={Vidmin:.3e}',
    f'.csparam Vidmax={Vidmax:.3e}',
    f'.csparam dVid={dVid:.3e}'
  ))
  simparFile = simulationPath + "simulation.dc.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

Vidsim=df_sim['v-sweep'].to_numpy()
Voutsim=df_sim['Vout'].to_numpy()

regexp = re.compile(r'voutmax' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutmax=float(match.group(1))

regexp = re.compile(r'voutmin' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutmin=float(match.group(1))

regexp = re.compile(r'vos' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Vos=float(match.group(1))

Voutq=0.9
Vswing=Voutmax-Voutmin
Adiff=Vswing/(Vidmax-Vidmin)
AdiffdB=20*log(abs(Adiff))

plt.plot([Vidmin/1e-6,Vos/1e-6],[Voutq,Voutq],'k--', linewidth=lw)
plt.plot([Vos/1e-6,Vos/1e-6],[0.6,Voutq],'k--', linewidth=lw)
#plt.plot([Vidmin/1e-3,Vidmax/1e-3],[Voutmax,Voutmax],'k--', linewidth=lw)
#plt.plot([Vidmin/1e-3,Vidmax/1e-3],[Voutmin,Voutmin],'k--', linewidth=lw)
plt.plot(Vidsim/1e-6,Voutsim,'r')
plt.xlim(Vidmin/1e-6,Vidmax/1e-6)
#plt.xticks(np.arange(-0.4465e-3,-0.4455e-3,0.0005e-3))
plt.xlabel('$V_{id}\\;[\\mu V]$')
plt.ylim(0.6,1.1)
#plt.yticks(np.arange(0.692,0.708,0.002))
plt.ylabel('$V_{out}$ [V]')
#plt.legend(loc='best')
textstr = '\n'.join((
  f'$V_{{DD}} =$ {VDD:.1f} V',
  f'$V_{{outq}} =$ {Voutq:.3f} V',
  f'$V_{{os}} =$ {Vos/1e-6:.1f} $\\mu V$',
  f'$V_{{outmax}} =$ {Voutmax:.3f} V',
  f'$V_{{outmin}} =$ {Voutmin:.3f} V',
  f'$V_{{swing}} =$ {Vswing:.2f} V',
  f'$A_{{diff}} =$ {Adiff:.3e}',
  f'$A_{{diff}} =$ {AdiffdB:.2f} dB'))
plt.text(1.05, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()

paramstr = '\n'.join((
  f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Ib1={Ib1/1e-9:.0f}n Ib2={Ib2/1e-6:.1f}u',
  f'.param CL={CL/1e-12:.0f}p Cc={Cc/1e-12:.1f}p',
  f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u',
  f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u',
  f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u',
  f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u',
  f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u'
  ))
#print(paramstr)

with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
```

We can now save a more accurate value of the offset voltage $V_{os} =$ `{python} f'{Vos/1e-3:.3f}'` $mV$ that is required to bring the output voltage to $V_{ic} =$  `{python} f'{Vic/1e-3:.0f}'` $mV$ and that will be used for the following .AC and .NOISE simulations.


## Open-loop gain
### Closed-loop circuit
As explained above we can extract the open-loop gain from the simulated closed-loop gain with the amplifier operating as a voltage follower. The OTA open-loop gain $A_{ol}(\omega)$ is then given by
\begin{equation}
  A_{ol}(\omega) = \frac{A_{cl}(\omega)}{1 - A_{cl}(\omega)},
\end{equation}
where $A_{cl}(\omega)$ is the simulated closed-loop transfer function and $A_{ol}(\omega)$, the computed open-loop transfer function. The above relation assumes that the open-loop DC gain is large enough for the input-referred offset voltage to be ignored. The simulations results are shown in @fig-ng_closed_loop_gain1.

```{python}
#| label: fig-ng_closed_loop_gain1
#| fig-cap: "Open-loop gain response extracted from the closed-loop simulations and compared to theoretical estimation."

simtype = ".ac"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + ".dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + ".log"

if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Vic={Vic:.1f} Ib1={Ib1/1e-9:.0f}n Ib2={Ib2/1e-6:.1f}u',
    f'.param CL={CL/1e-12:.0f}p Cc={Cc/1e-12:.1f}p',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u',
    f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u',
    f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u',
    f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u',
    f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u'
    ))
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')
fsim=df_sim['frequency'].to_numpy()
ReAcl=df_sim['vr(out)'].to_numpy()
ImAcl=df_sim['vi(out)'].to_numpy()
AclmagdBng=df_sim['AclmagdB'].to_numpy()
Aclphidegng=df_sim['Aclphdeg'].to_numpy()
AolmagdBng=df_sim['AolmagdB'].to_numpy()
Aolphdegng=df_sim['Aolphdeg'].to_numpy()
Acl=ReAcl+ImAcl*1.0j
Npts=len(fsim)
fmin=fsim[0]
fmax=fsim[Npts-1]

Aol=np.zeros(Npts, dtype=complex)
AclmagdBsim=np.zeros(Npts)
AolmagdBsim=np.zeros(Npts)
Aclphidegsim=np.zeros(Npts)
Aolphidegsim=np.zeros(Npts)
AclmagdBsim=20*log(np.absolute(Acl))
Aclphidegsim=np.angle(Acl)
#Aol=Acl/(1-Acl)
#AolmagdBsim=20*log(np.absolute(Aol))
#Aolphidegsim=np.angle(Aol, deg=True)

for k in range(0,Npts):
  Aol[k]=1/(1/Acl[k]-1)
  AolmagdBsim[k]=20*log(np.absolute(Aol[k]))
  Aolphidegsim[k]=np.angle(Aol[k])

Aclphidegsim=np.unwrap(Aclphidegsim)*180/pi
Aolphidegsim=np.unwrap(Aolphidegsim)*180/pi

AdcdBsim=np.max(AolmagdBsim)
idx=np.where(np.diff(np.sign(AolmagdBsim)))[0]
GBWsim=fsim[idx][0]
PGBWsim=Aolphidegsim[idx][0]
PMsim=180+PGBWsim

plt.style.use('plt_style_small.mplstyle')
params = {'figure.figsize': (5,5)}
plt.rcParams.update(params)
    
fig, axs = plt.subplots(2, sharex=True)

axs[0].semilogx([fmin,GBWsim],[0,0],'k--', linewidth=lw)
axs[0].semilogx([GBWsim,GBWsim],[0,-60],'k--', linewidth=lw)
axs[0].semilogx(fsim,AclmagdBsim,'b',label='Closed-loop gain (Simulation)')
axs[0].semilogx(fsim,AolmagdBsim,'r',label='Open-loop gain (Simulation)')
#axs[0].semilogx(fsim,AolmagdBng,'m--',label='Open-loop gain (ngspice)')
axs[0].semilogx(fthe,AmagdBthe,'r--',label='Open-loop gain (Theory)')
axs[0].set(xlim=(fmin,fmax), ylim=(-60,120), ylabel='$|A_{vd}|$ [dB]')
axs[0].set_yticks([-60,-40,-20,0,20,40,60,80,100,120])
axs[0].legend(loc='lower left')
textstr1 = '\n'.join((
  f'$A_{{dc}} =$ {AdcdBthe:.1f} dB (theory)',
  f'$A_{{dc}} =$ {AdcdBsim:.1f} dB (sim.)',
  f'$GBW =$ {GBWthe/1e6:.1f} GHz (theory)',
  f'$GBW =$ {GBWsim/1e6:.1f} GHz (sim.)'))
axs[0].text(1.05, 0.5, textstr1, ha='left', va='center', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogx([fmin,GBWsim],[PGBWsim,PGBWsim],'k--', linewidth=lw)
axs[1].semilogx([GBWsim,GBWsim],[PGBWsim,0],'k--', linewidth=lw)
axs[1].semilogx(fsim,Aclphidegsim,'b',label='Closed-loop gain (Simulation)')
axs[1].semilogx(fsim,Aolphidegsim,'r',label='Open-loop gain (Simulation)')
#axs[1].semilogx(fsim,Aolphdegng,'m--',label='Open-loop gain (ngspice)')
axs[1].semilogx(fthe,Aphidegthe,'r--',label='Open-loop gain (Theory)')
axs[1].set(ylim=(-180,0), xlabel='Frequency [Hz]', ylabel='$arg\\{A_{vd}\\}$ [degree]')
axs[1].set_xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
axs[1].set_yticks([-180,-135,-90,-45,0])
#axs[1].legend(loc='best')
textstr2 = '\n'.join((
  f'$PM =$ {PMthe:.1f}$^{{\\circ}}$ (theory)',
  f'$PM =$ {PMsim:.1f}$^{{\\circ}}$ (sim.)'))
axs[1].text(0.03, 0.05, textstr2, ha='left', va='bottom', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
arrow = mpatches.FancyArrowPatch((GBWsim, PGBWsim), (GBWsim, -180),
                                 arrowstyle='<|-|>', color="black", mutation_scale=15)
axs[1].add_patch(arrow)
axs[1].annotate(f'Phase margin = {PMsim:.0f}$^{{\\circ}}$ ', (0, 0.5), xycoords=arrow, ha='right', va='center', size=9)
plt.subplots_adjust(hspace=0.1)
plt.show()
```

From @fig-ng_closed_loop_gain1, we see that the simulated $GBW$ is close to the theoretical value and slightly above the specs. The calculated open-loop gain does not seem to give correct results at low frequency. The main reason for this is that the way the open-loop gain is calculated does not account for a large offset voltage which reduces the resulting open-loop DC gain. The phase also looks incorrect at low-frequency. It is equal to $-180^{\circ}$ at low frequency which indicates that the gain is negative. If we want to account for the offset voltage we need to compute the open-loop gain according to
\begin{equation}
  A_{ol}(\omega) = \frac{1}{\frac{V_{in} - V_{os}}{V_{out}(\omega)} - 1} = \frac{1}{\frac{V_{in}}{V_{out}(\omega)} - \frac{V_{os}}{V_{out}(\omega)} - 1}.
\end{equation}
Replacing $V_{out}(\omega) = A_{cl}(\omega) \cdot V_{in}$, we get
\begin{equation}
  A_{ol}(\omega) = \frac{1}{\frac{1}{A_{cl}(\omega)}\,\left(1-\frac{V_{os}}{V_{in}}\right) - 1},
\end{equation}
which dependends on $V_{in}$. Now, in AC analysis, the amplitude of the small-signal input voltage $V_{in} = 1$ and therefore
\begin{equation}
  A_{ol}(\omega) = \frac{1}{\frac{1-V_{os}}{A_{cl}(\omega)} - 1}.
\end{equation}
The open-loop gain extracted from the closed-loop small-signal simulation accounting for the effect of the offset voltage is presented in @fig-ng_closed_loop_gain2.

```{python}
#| label: fig-ng_closed_loop_gain2
#| fig-cap: "Open-loop gain response extracted from the closed-loop simulations including the effect of the offset voltage."

Voscl=-0.265e-3

for k in range(0,Npts):
  Aol[k]=1/((1-Voscl)/Acl[k]-1)
  AolmagdBsim[k]=20*log(np.absolute(Aol[k]))
  Aolphidegsim[k]=np.angle(Aol[k])

Aolphidegsim=np.unwrap(Aolphidegsim)*180/pi

AdcdBsim=np.max(AolmagdBsim)
idx=np.where(np.diff(np.sign(AolmagdBsim)))[0]
GBWsim=fsim[idx][0]
PGBWsim=Aolphidegsim[idx][0]
PMsim=180+PGBWsim

plt.style.use('plt_style_small.mplstyle')
params = {'figure.figsize': (5,5)}
plt.rcParams.update(params)
    
fig, axs = plt.subplots(2, sharex=True)

axs[0].semilogx([fmin,GBWsim],[0,0],'k--', linewidth=lw)
axs[0].semilogx([GBWsim,GBWsim],[0,-60],'k--', linewidth=lw)
axs[0].semilogx(fsim,AclmagdBsim,'b',label='Closed-loop gain (Simulation)')
axs[0].semilogx(fsim,AolmagdBsim,'r',label='Open-loop gain (Simulation)')
#axs[0].semilogx(fsim,AolmagdBng,'m--',label='Open-loop gain (ngspice)')
axs[0].semilogx(fthe,AmagdBthe,'r--',label='Open-loop gain (Theory)')
axs[0].set(xlim=(fmin,fmax), ylim=(-60,120), ylabel='$|A_{vd}|$ [dB]')
axs[0].set_yticks([-60,-40,-20,0,20,40,60,80,100,120])
axs[0].legend(loc='lower left')
textstr1 = '\n'.join((
  f'$V_{{os}} =$ {Voscl/1e-3:.3f} $mV$',
  f'$A_{{dc}} =$ {AdcdBthe:.1f} dB (theory)',
  f'$A_{{dc}} =$ {AdcdBsim:.1f} dB (sim.)',
  f'$GBW =$ {GBWthe/1e6:.1f} GHz (theory)',
  f'$GBW =$ {GBWsim/1e6:.1f} GHz (sim.)'))
axs[0].text(1.05, 0.5, textstr1, ha='left', va='center', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogx([fmin,GBWsim],[PGBWsim,PGBWsim],'k--', linewidth=lw)
axs[1].semilogx([GBWsim,GBWsim],[PGBWsim,0],'k--', linewidth=lw)
axs[1].semilogx(fsim,Aclphidegsim,'b',label='Closed-loop gain (Simulation)')
axs[1].semilogx(fsim,Aolphidegsim,'r',label='Open-loop gain (Simulation)')
#axs[1].semilogx(fsim,Aolphdegng,'m--',label='Open-loop gain (ngspice)')
axs[1].semilogx(fthe,Aphidegthe,'r--',label='Open-loop gain (Theory)')
axs[1].set(ylim=(-180,0), xlabel='Frequency [Hz]', ylabel='$arg\\{A_{vd}\\}$ [degree]')
axs[1].set_xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
axs[1].set_yticks([-180,-135,-90,-45,0])
#axs[1].legend(loc='best')
textstr2 = '\n'.join((
  f'$PM =$ {PMthe:.1f}$^{{\\circ}}$ (theory)',
  f'$PM =$ {PMsim:.1f}$^{{\\circ}}$ (sim.)'))
axs[1].text(0.03, 0.05, textstr2, ha='left', va='bottom', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
arrow = mpatches.FancyArrowPatch((GBWsim, PGBWsim), (GBWsim, -180),
                                 arrowstyle='<|-|>', color="black", mutation_scale=15)
axs[1].add_patch(arrow)
axs[1].annotate(f'Phase margin = {PMsim:.0f}$^{{\\circ}}$ ', (0, 0.5), xycoords=arrow, ha='right', va='center', size=9)
plt.subplots_adjust(hspace=0.1)
plt.show()
```

From @fig-ng_closed_loop_gain2, we see now a much better estimation of the open-loop gain and a correct phase at low frequency. We had to adjust the offset voltage to a value $V_{os} =$ `{python} f'{Voscl/1e-3:.3f}'` $mV$, which is slightly larger than the one extracted in the operating point simulation $V_{os} =$ `{python} f'{Vos/1e-3:.3f}'` $mV$.

Having extracted the offset voltage, we can also simulate the open-loop gain directly in open-loop configuration.

### Open-loop circuit
After having checked the operating point information, extracted the offset voltage and making sure that the OTA output is not saturated, we can now proceed with the open-loop gain simulation. The simulation results are presented in @fig-ng_open_loop_gain.

```{python}
#| label: fig-ng_open_loop_gain
#| fig-cap: "Simulated gain response compared to theoretical estimation."

simtype = ".ac"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + ".dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + ".log"

if newSim:
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')
fsim=df_sim['frequency'].to_numpy()
AmagdBsim=df_sim['AmagdB'].to_numpy()
Aphidegsim=df_sim['Aphdeg'].to_numpy()
Npts=len(fsim)
fmin=fsim[0]
#fmin=10
fmax=fsim[Npts-1]

for k in range(0,Npts):
  if Aphidegsim[k]>0:
    Aphidegsim[k]=Aphidegsim[k]-360

regexp = re.compile(r'adc' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      AdcdBsim=float(match.group(1))

regexp = re.compile(r'gbw' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      GBWsim=float(match.group(1))

regexp = re.compile(r'pgbw' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      PGBWsim=float(match.group(1))

PMsim=180+PGBWsim

plt.style.use('plt_style_small.mplstyle')
params = {'figure.figsize': (5,5)}
plt.rcParams.update(params)
    
fig, axs = plt.subplots(2, sharex=True)

axs[0].semilogx([fmin,GBWsim],[0,0],'k--', linewidth=lw)
axs[0].semilogx([GBWsim,GBWsim],[0,-60],'k--', linewidth=lw)
axs[0].semilogx(fsim,AmagdBsim,'r',label='Simulation')
axs[0].semilogx(fthe,AmagdBthe,'r--',label='Theory')
axs[0].set(xlim=(fmin,fmax), ylim=(-60,120), ylabel='$|A_{vd}|$ [dB]')
axs[0].set_yticks([-60,-40,-20,0,20,40,60,80,100,120])
axs[0].legend(loc='upper right')
textstr1 = '\n'.join((
  f'$A_{{dc}} =$ {AdcdBthe:.1f} dB (theory)',
  f'$A_{{dc}} =$ {AdcdBsim:.1f} dB (sim.)',
  f'$GBW =$ {GBWthe/1e6:.1f} GHz (theory)',
  f'$GBW =$ {GBWsim/1e6:.1f} GHz (sim.)'))
axs[0].text(0.03, 0.07, textstr1, ha='left', va='bottom', transform=axs[0].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogx([fmin,GBWsim],[PGBWsim,PGBWsim],'k--', linewidth=lw)
axs[1].semilogx([GBWsim,GBWsim],[PGBWsim,0],'k--', linewidth=lw)
axs[1].semilogx(fsim,Aphidegsim,'b',label='Simulation')
axs[1].semilogx(fthe,Aphidegthe,'b--',label='Theory')
axs[1].set(xlim=(fmin,fmax), ylim=(-180,0), xlabel='Frequency [Hz]', ylabel='$arg\\{A_{vd}\\}$ [degree]')
axs[1].set_xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
axs[1].set_yticks([-180,-135,-90,-45,0])
axs[1].legend(loc='best')
textstr2 = '\n'.join((
  f'$PM =$ {PMthe:.1f}$^{{\\circ}}$ (theory)',
  f'$PM =$ {PMsim:.1f}$^{{\\circ}}$ (sim.)'))
axs[1].text(0.03, 0.05, textstr2, ha='left', va='bottom', transform=axs[1].transAxes, size=9,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
arrow = mpatches.FancyArrowPatch((GBWsim, PGBWsim), (GBWsim, -180),
                                 arrowstyle='<|-|>', color="black", mutation_scale=15)
axs[1].add_patch(arrow)
axs[1].annotate(f'Phase margin = {PMsim:.0f}$^{{\\circ}}$ ', (0, 0.5), xycoords=arrow, ha='right', va='center', size=9)
plt.subplots_adjust(hspace=0.1)
plt.show()
```

The results of the open-loop simulation in @fig-ng_open_loop_gain are close to the theoretical estimation. The simulated $GBW$ is equal to the theoretical estimation and to the value extracted from the closed-loop simulation and slightly higher than the specification. The DC gain is larger than the theoretical prediction and well above the specification. Finally the phase margin is sligtly smaller than the theoretical estimation but close to the specification. This is probably due to the zero being at lower frequency.

## Input-referred noise
The simulated input-referred noise PSD is presented in @fig-ng_noise and compared to the theoretical estimation.

```{python}
#| label: fig-ng_noise
#| fig-cap: "Simulated input-referred noise PSD compared to theoretical estimation."

simtype = ".nz"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Gain/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
simulationRaw = simulationPath + fileName + ".raw"
ngspiceDataFile = simulationPath + otaName + version + simtype + ".dat"
ngspiceRawFile = simulationPath + otaName + version + simtype + ".raw"
ngspiceLogFile = simulationPath + otaName + version + simtype + ".log"

if newSim:
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  shutil.copy2(simulationRaw, ngspiceRawFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

fsim=df_sim['frequency'].to_numpy()
Vnout=df_sim['onoise_spectrum'].to_numpy()
Vnin=df_sim['inoise_spectrum'].to_numpy()
SnoutdBvsim=20*log(Vnout)
SnindBvsim=20*log(Vnin)

Npts=len(fsim)
fmin=fsim[0]
fmax=fsim[Npts-1]

plt.style.use('plt_style_small.mplstyle')
plt.semilogx([fkthe,fkthe],[-150,S0dBvthe],'k--',linewidth=lw)
plt.semilogx(fsim,SnindBvsim,'r-', markevery=25, label='Total (sim.)')
plt.semilogx(fthenz,SninthdBvthe,'b--', label='Thermal (theory)')
plt.semilogx(fthenz,SninfldBvthe,'g--', label='Flicker (theory)')
plt.semilogx(fthenz,SnindBvthe,'r--', label='Total (theory)')
plt.xlim(fmin,fmax)
plt.xticks([1e0,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-150,-90)
plt.ylabel(r'Input Noise PSD $[dBv/\sqrt{Hz}]$')
#plt.legend(loc='best')
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
textstr = '\n'.join((
    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$ (theory)',
#    f'$S_{{nin,th}} =$ {S0dBvsim:.1f} $dBv/\\sqrt{{Hz}}$ (sim.)',
    f'$f_k =$ {fkthe/1e3:.1f} kHz (theory)'))
#    f'$f_k =$ {fksim/1e3:.1f} kHz (sim.)'))
plt.text(0.35, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

From @fig-ng_noise, we see that the simulated input-referred noise PSD perfectly matches the theoretical estimation. We can have a closer look at the contributions of the various transistors to the input-referred white noise PSD. The contributions of M~1a~-M~1b~, M~2~, M~3a~-M~3b~, M~4a~-M~4b~ and M~5a~-M~5b~ to the input-referred white noise PSD are detailed in @fig-ng_white_noise_contributions and compared to the theoretical white noise.

```{python}
#| label: fig-ng_white_noise_contributions
#| fig-cap: "Breakdown of the contributions to the simulated input-referred white noise PSD."

regexp = re.compile(r'No. Variables:' + refloat)
with open(ngspiceRawFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      Nvar=int(match.group(1))

#print(Nvar)

regexp = re.compile(r'No. Points:' + refloat)
with open(ngspiceRawFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      Npts=int(match.group(1))

#print(Npts)

df_noise=pd.read_table(ngspiceRawFile, sep=r'\s+', skiprows=(38), skip_blank_lines=True, header=None, dtype=np.float64, engine='python')

freq=np.zeros(Npts)
Vnin=np.zeros(Npts)
VnoutM1a=np.zeros(Npts)
VnoutM1af=np.zeros(Npts)
VnoutM1aw=np.zeros(Npts)
VnoutM1b=np.zeros(Npts)
VnoutM1bf=np.zeros(Npts)
VnoutM1bw=np.zeros(Npts)
VnoutM2=np.zeros(Npts)
VnoutM2f=np.zeros(Npts)
VnoutM2w=np.zeros(Npts)
VnoutM3a=np.zeros(Npts)
VnoutM3af=np.zeros(Npts)
VnoutM3aw=np.zeros(Npts)
VnoutM3b=np.zeros(Npts)
VnoutM3bf=np.zeros(Npts)
VnoutM3bw=np.zeros(Npts)
VnoutM4a=np.zeros(Npts)
VnoutM4af=np.zeros(Npts)
VnoutM4aw=np.zeros(Npts)
VnoutM4b=np.zeros(Npts)
VnoutM4bf=np.zeros(Npts)
VnoutM4bw=np.zeros(Npts)
VnoutM5a=np.zeros(Npts)
VnoutM5af=np.zeros(Npts)
VnoutM5aw=np.zeros(Npts)
VnoutM5b=np.zeros(Npts)
VnoutM5bf=np.zeros(Npts)
VnoutM5bw=np.zeros(Npts)
Vnout=np.zeros(Npts)
SnoutM1=np.zeros(Npts)
SnoutM1f=np.zeros(Npts)
SnoutM1w=np.zeros(Npts)
SnoutM2=np.zeros(Npts)
SnoutM2f=np.zeros(Npts)
SnoutM2w=np.zeros(Npts)
SnoutM3=np.zeros(Npts)
SnoutM3f=np.zeros(Npts)
SnoutM3w=np.zeros(Npts)
SnoutM4=np.zeros(Npts)
SnoutM4f=np.zeros(Npts)
SnoutM4w=np.zeros(Npts)
SnoutM5=np.zeros(Npts)
SnoutM5f=np.zeros(Npts)
SnoutM5w=np.zeros(Npts)
SninM1=np.zeros(Npts)
SninM1f=np.zeros(Npts)
SninM1w=np.zeros(Npts)
SninM1dBv=np.zeros(Npts)
SninM1fdBv=np.zeros(Npts)
SninM1wdBv=np.zeros(Npts)
SninM2=np.zeros(Npts)
SninM2f=np.zeros(Npts)
SninM2w=np.zeros(Npts)
SninM2dBv=np.zeros(Npts)
SninM2fdBv=np.zeros(Npts)
SninM2wdBv=np.zeros(Npts)
SninM3=np.zeros(Npts)
SninM3f=np.zeros(Npts)
SninM3w=np.zeros(Npts)
SninM3dBv=np.zeros(Npts)
SninM3fdBv=np.zeros(Npts)
SninM3wdBv=np.zeros(Npts)
SninM4=np.zeros(Npts)
SninM4f=np.zeros(Npts)
SninM4w=np.zeros(Npts)
SninM4dBv=np.zeros(Npts)
SninM4fdBv=np.zeros(Npts)
SninM4wdBv=np.zeros(Npts)
SninM5=np.zeros(Npts)
SninM5f=np.zeros(Npts)
SninM5w=np.zeros(Npts)
SninM5dBv=np.zeros(Npts)
SninM5fdBv=np.zeros(Npts)
SninM5wdBv=np.zeros(Npts)
SnoutdBv=np.zeros(Npts)
Snin=np.zeros(Npts)
SnindBv=np.zeros(Npts)
A=np.zeros(Npts)
Sninf=np.zeros(Npts)
SninfdBv=np.zeros(Npts)
Sninw=np.zeros(Npts)
SninwdBv=np.zeros(Npts)
for k in range(0,Npts):
  freq[k]=df_noise.iloc[Nvar*k,1]
  Vnin[k]=df_noise.iloc[Nvar*k+1,0]
  VnoutM1a[k]=df_noise.iloc[Nvar*k+2,0]
  VnoutM1af[k]=df_noise.iloc[Nvar*k+3,0]
  VnoutM1aw[k]=df_noise.iloc[Nvar*k+4,0]
  VnoutM1b[k]=df_noise.iloc[Nvar*k+5,0]
  VnoutM1bf[k]=df_noise.iloc[Nvar*k+6,0]
  VnoutM1bw[k]=df_noise.iloc[Nvar*k+7,0]
  VnoutM2[k]=df_noise.iloc[Nvar*k+8,0]
  VnoutM2f[k]=df_noise.iloc[Nvar*k+9,0]
  VnoutM2w[k]=df_noise.iloc[Nvar*k+10,0]
  VnoutM3a[k]=df_noise.iloc[Nvar*k+11,0]
  VnoutM3af[k]=df_noise.iloc[Nvar*k+12,0]
  VnoutM3aw[k]=df_noise.iloc[Nvar*k+13,0]
  VnoutM3b[k]=df_noise.iloc[Nvar*k+14,0]
  VnoutM3bf[k]=df_noise.iloc[Nvar*k+15,0]
  VnoutM3bw[k]=df_noise.iloc[Nvar*k+16,0]
  VnoutM4a[k]=df_noise.iloc[Nvar*k+17,0]
  VnoutM4af[k]=df_noise.iloc[Nvar*k+18,0]
  VnoutM4aw[k]=df_noise.iloc[Nvar*k+19,0]
  VnoutM4b[k]=df_noise.iloc[Nvar*k+20,0]
  VnoutM4bf[k]=df_noise.iloc[Nvar*k+21,0]
  VnoutM4bw[k]=df_noise.iloc[Nvar*k+22,0]
  VnoutM5a[k]=df_noise.iloc[Nvar*k+23,0]
  VnoutM5af[k]=df_noise.iloc[Nvar*k+24,0]
  VnoutM5aw[k]=df_noise.iloc[Nvar*k+25,0]
  VnoutM5b[k]=df_noise.iloc[Nvar*k+26,0]
  VnoutM5bf[k]=df_noise.iloc[Nvar*k+27,0]
  VnoutM5bw[k]=df_noise.iloc[Nvar*k+28,0]
  Vnout[k]=df_noise.iloc[Nvar*k+29,0]
  SnoutM1[k]=VnoutM1a[k]**2+VnoutM1b[k]**2
  SnoutM1f[k]=VnoutM1af[k]**2+VnoutM1bf[k]**2
  SnoutM1w[k]=VnoutM1aw[k]**2+VnoutM1bw[k]**2
  SnoutM2[k]=VnoutM2[k]**2
  SnoutM2f[k]=VnoutM2f[k]**2
  SnoutM2w[k]=VnoutM2w[k]**2
  SnoutM3[k]=VnoutM3a[k]**2+VnoutM3b[k]**2
  SnoutM3f[k]=VnoutM3af[k]**2+VnoutM3bf[k]**2
  SnoutM3w[k]=VnoutM3aw[k]**2+VnoutM3bw[k]**2
  SnoutM4[k]=VnoutM4a[k]**2+VnoutM4b[k]**2
  SnoutM4f[k]=VnoutM4af[k]**2+VnoutM4bf[k]**2
  SnoutM4w[k]=VnoutM4aw[k]**2+VnoutM4bw[k]**2
  SnoutM5[k]=VnoutM5a[k]**2+VnoutM5b[k]**2
  SnoutM5f[k]=VnoutM5af[k]**2+VnoutM5bf[k]**2
  SnoutM5w[k]=VnoutM5aw[k]**2+VnoutM5bw[k]**2
  A[k]=Vnout[k]/Vnin[k]
  Snin[k]=Vnin[k]**2
  SnindBv[k]=10*log(Snin[k])
  SninM1[k]=SnoutM1[k]/A[k]**2
  SninM1f[k]=SnoutM1f[k]/A[k]**2
  SninM1w[k]=SnoutM1w[k]/A[k]**2
  SninM1dBv[k]=10*log(SninM1[k])
  SninM1fdBv[k]=10*log(SninM1f[k])
  SninM1wdBv[k]=10*log(SninM1w[k])
  SninM2[k]=SnoutM2[k]/A[k]**2
  SninM2f[k]=SnoutM2f[k]/A[k]**2
  SninM2w[k]=SnoutM2w[k]/A[k]**2
  SninM2dBv[k]=10*log(SninM2[k])
  SninM2fdBv[k]=10*log(SninM2f[k])
  SninM2wdBv[k]=10*log(SninM2w[k])
  SninM3[k]=SnoutM3[k]/A[k]**2
  SninM3f[k]=SnoutM3f[k]/A[k]**2
  SninM3w[k]=SnoutM3w[k]/A[k]**2
  SninM3dBv[k]=10*log(SninM3[k])
  SninM3fdBv[k]=10*log(SninM3f[k])
  SninM3wdBv[k]=10*log(SninM3w[k])
  SninM4[k]=SnoutM4[k]/A[k]**2
  SninM4f[k]=SnoutM4f[k]/A[k]**2
  SninM4w[k]=SnoutM4w[k]/A[k]**2
  SninM4dBv[k]=10*log(SninM4[k])
  SninM4fdBv[k]=10*log(SninM4f[k])
  SninM4wdBv[k]=10*log(SninM4w[k])
  SninM5[k]=SnoutM5[k]/A[k]**2
  SninM5f[k]=SnoutM5f[k]/A[k]**2
  SninM5w[k]=SnoutM5w[k]/A[k]**2
  SninM5dBv[k]=10*log(SninM5[k])
  SninM5fdBv[k]=10*log(SninM5f[k])
  SninM5wdBv[k]=10*log(SninM5w[k])
  Sninf[k]=Vnin[k]**2
  Sninw[k]=SninM1w[k]+SninM2w[k]+SninM3w[k]+SninM4w[k]+SninM5w[k]
  SninfdBv[k]=10*log(Sninf[k])
  SninwdBv[k]=10*log(Sninw[k])

#S0sim=Sninw[0]
#Rninthsim=S0sim/(4*kT)
#gammanotasim=df_mos.at["M1a","Gm"]*Rninthsim

Sninw1ksim=Sninw[np.where(freq > 1000)[0][0]]
Sninw1kdBvsim=10*log(abs(Sninw1ksim))
Sninw1kthe=Sninththe[np.where(fthenz > 1000)[0][0]]
Sninw1kdBvthe=10*log(abs(Sninw1kthe))
SninM1w1ksim=SninM1w[np.where(freq > 1000)[0][0]]
SninM2w1ksim=SninM2w[np.where(freq > 1000)[0][0]]
SninM4w1ksim=SninM4w[np.where(freq > 1000)[0][0]]
SninM5w1ksim=SninM5w[np.where(freq > 1000)[0][0]]
etathsim=(SninM2w1ksim+SninM4w1ksim+SninM5w1ksim)/SninM1w1ksim
etathdBsim=10*log(abs(etathsim))
Rninthsim=Sninw1ksim/(4*kT)
gammanotasim=df_mos.at["M1a","Gm"]*Rninthsim
gamman4sim=df_mos.at["M4a","gamman"]

fmin=freq[0]
fmax=freq[Npts-1]

plt.style.use('plt_style_small.mplstyle')
plt.semilogx(freq,SninM1wdBv,'b-', label='M1a-M1b')
plt.semilogx(freq,SninM2wdBv,'g-', label='M2')
plt.semilogx(freq,SninM3wdBv,'y-', label='M3a-M3b')
plt.semilogx(freq,SninM4wdBv,'m-', label='M4a-M4b')
plt.semilogx(freq,SninM5wdBv,'c-', label='M5a-M5b')
plt.semilogx(freq,SninwdBv,'r-', label='Total (sim.)')
plt.semilogx(fthenz,SninthdBvthe,'r--', label='Total (theory)')
plt.xlim(fmin,fmax)
plt.xticks([1e0,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-180,-120)
#plt.yticks(range(-150,-100,10))
plt.ylabel('Input Noise PSD $[dBv/\\sqrt{Hz}]$')
#plt.legend(loc='lower left')
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
#textstr = '\n'.join((
#    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$ (theory)',
#    f'$S_{{nin,th}} =$ {S0dBvsim:.1f} $dBv/\\sqrt{{Hz}}$ (sim.)',
#    f'$f_k =$ {fkthe/1e3:.1f} kHz (theory)'))
#    f'$f_k =$ {fksim/1e3:.1f} kHz (sim.)'))
#plt.text(0.35, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

From  @fig-ng_white_noise_contributions, we can observe that the total simulated white noise is equal to the theoretical estimation. The white noise is dominated by the differential pair M~1a~-M~1b~ which is $1+\eta_{th} =$ `{python} f'{1+etathsim:.3f}'` times (or `{python} f'{10*log(abs(1+etathsim)):.3f}'` dB) lower than the total white noise.  The contribution of M~4a~-M~4b~ is about $\eta_{th} =$ `{python} f'{etathsim:.3f}'` times (or  `{python} f'{-etathdBsim:.3f}'` dB) lower than the contribution of M~1a~-M~1b~. The simulated value of $\eta_{th} =$ `{python} f'{etathsim:.3f}'` is about equal to the theoretical estimation `{python} f'{etath:.3f}'`. The OTA thermal noise excess factor $\gamma_{n,ota} =$  `{python} f'{gammanotasim:.3f}'` is about equal to the predicted value $\gamma_{n,ota} =$  `{python} f'{gammanotathe:.3f}'`. @fig-ng_white_noise_contributions also shows that the noise contributions of  M~2~ and M~5a~-M~5b~ are negligible at lower frequency thanks to the gain of the 1^st^-stage. It also shows that the contribution of M~3a~-M~3b~ is negligible simply because it is a common-mode current contribution which is canceled at the output of the 1^st^-stage.

@fig-ng_flicker_noise_contributions presents the breakdown of the contributions of the various transistors to the input-referred flicker noise. As expected from the value of $\eta_{fl} =$ `{python} f'{etafl:.3f}'` in @tbl-flicker, the flicker noise is dominated by the current mirror M~4a~-M~4b~. The contribution of the differential pair is about 10 dB lower and the contributions of M~2~ and M~5a~-M~5b~ more than 30 dB lower.

The breakdown of the contributions of the various transistors to the total input-referred noise is presented in @fig-ng_flicker_noise_contributions.
```{python}
#| label: fig-ng_flicker_noise_contributions
#| fig-cap: "Breakdown of the contributions to the simulated input-referred flicker noise PSD."

Sninf1Hzsim=Snin[0]
Sninf1HzdBvsim=10*log(abs(Sninf1Hzsim))
Sninf1Hzthe=Sninththe[0]
Sninf1HzdBvthe=10*log(abs(Sninf1Hzthe))
SninM1f1Hzsim=SninM1f[0]
SninM2f1Hzsim=SninM2f[0]
SninM4f1Hzsim=SninM4f[0]
SninM5f1Hzsim=SninM5f[0]
etaflsim=(SninM2f1Hzsim+SninM4f1Hzsim+SninM5f1Hzsim)/SninM1f1Hzsim
etafldBsim=10*log(abs(etaflsim))

plt.style.use('plt_style_small.mplstyle')
plt.semilogx(freq,SninM1fdBv,'b-', label='M1a-M1b')
plt.semilogx(freq,SninM2fdBv,'g-', label='M2')
plt.semilogx(freq,SninM3fdBv,'y-', label='M3a-M3b')
plt.semilogx(freq,SninM4fdBv,'m-', label='M4a-M4b')
plt.semilogx(freq,SninM5fdBv,'c-', label='M5a-M5b')
plt.semilogx(freq,SninfdBv,'r-', label='Total (sim.)')
plt.semilogx(fthenz,SninfldBvthe,'r--', label='Total (theory)')
plt.xlim(fmin,1e5)
#plt.xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-180,-90)
plt.yticks(range(-180,-80,10))
plt.ylabel('Input Noise PSD $[dBv/\\sqrt{Hz}]$')
#plt.legend(loc='lower left')
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
#textstr = '\n'.join((
#    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$ (theory)',
#    f'$S_{{nin,th}} =$ {S0dBvsim:.1f} $dBv/\\sqrt{{Hz}}$ (sim.)',
#    f'$f_k =$ {fkthe/1e3:.1f} kHz (theory)'))
#    f'$f_k =$ {fksim/1e3:.1f} kHz (sim.)'))
#plt.text(0.35, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

We can observe that the simulation of the total input-referred flicker noise PSD perfectly matches the theoretical estimation. We also see that the flicker noise is dominated by the contribution of the input differential pair M~1a~-M~1b~ which is confirmed by the simulated value of $\eta_{f} =$ `{python} f'{etaflsim:.3f}'` which is even lower than the theoretical estimation $\eta_{f} =$ `{python} f'{etafl:.3f}'`. This is due to the higher simulated gain. The contribution of the current mirror M~4a~-M~4b~ is about `{python} f'{10*log(SninM1f1Hzsim/SninM4f1Hzsim):.3f}'` dB lower than that of the differential pair M~1a~-M~1b~.

```{python}
#| label: fig-ng_noise_contributions
#| fig-cap: "Breakdown of the contributions to the simulated input-referred noise PSD."

plt.style.use('plt_style_small.mplstyle')
plt.semilogx(freq,SninM1dBv,'b-', label='M1a-M1b (total)')
#plt.semilogx(freq,SninM1fdBv,'b-.', label='M1a-M1b (flicker)')
#plt.semilogx(freq,SninM1wdBv,'b--', label='M1a-M1b (white)')
plt.semilogx(freq,SninM2dBv,'g-', label='M2 (total)')
#plt.semilogx(freq,SninM2fdBv,'g-.', label='M2a-M2b-M2c-M2d (flicker)')
#plt.semilogx(freq,SninM2wdBv,'g--', label='M2a-M2b-M2c-M2d (white)')
plt.semilogx(freq,SninM4dBv,'m-', label='M4a-M4b')
plt.semilogx(freq,SninM5dBv,'c-', label='M5a-M5b')
#plt.semilogx(freq,SninfdBv,'r--', label='Total (flicker)')
#plt.semilogx(freq,SninwdBv,'r-.', label='Total (white)')
plt.semilogx(freq,SnindBv,'r-', label='Total')
#plt.semilogx(fthe,SninthdBvthe,'k--', label='Thermal (theory)')
#plt.semilogx(fthe,SninfldBvthe,'k--', label='Flicker (theory)')
plt.semilogx(fthenz,SnindBvthe,'r--', label='Total (theory)')
plt.xlim(fmin,fmax)
plt.xticks([1e0,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
plt.xlabel('Frequency [Hz]')
plt.ylim(-150,-90)
plt.yticks(range(-150,-80,10))
plt.ylabel('Input Noise PSD $[dBv/\\sqrt{Hz}]$')
#plt.legend(loc='lower left')
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
#textstr = '\n'.join((
#    f'$S_{{nin,th}} =$ {S0dBvthe:.1f} $dBv/\\sqrt{{Hz}}$ (theory)',
#    f'$S_{{nin,th}} =$ {S0dBvsim:.1f} $dBv/\\sqrt{{Hz}}$ (sim.)',
#    f'$f_k =$ {fkthe/1e3:.1f} kHz (theory)'))
#    f'$f_k =$ {fksim/1e3:.1f} kHz (sim.)'))
#plt.text(0.35, 0.95, textstr, ha='left', va='top', size=9, transform=plt.gca().transAxes,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

## Input common-mode voltage range
We can check the input common-mode voltage range by connecting the OTA as a voltage follower and sweeping the positive input.

```{python}
#| label: fig-ng_cm_range
#| fig-cap: "Simulated input common-mode voltage range."

simtype = ".dc"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + otaName + version + simtype + "1.dat"
ngspiceLogFile = simulationPath + otaName + version + simtype + "1.log"

Vinmin=0
Vinmax=VDD
dVin=10e-3
Vcmmax=1.5

if newSim:
  simpar = '\n'.join((
    f'.csparam Vinmin={Vinmin:.3e}',
    f'.csparam Vinmax={Vinmax:.3e}',
    f'.csparam dVin={dVin:.3e}'
  ))
  simparFile = simulationPath + "simulation.dc.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

Vinsim=df_sim['v-sweep'].to_numpy()
Voutsim=df_sim['Vout'].to_numpy()
plt.plot([Vinmin,Vcmmax],[Vcmmax,Vcmmax],'k--', linewidth=lw)
plt.plot([Vcmmax,Vcmmax],[0,Vcmmax],'k--', linewidth=lw)
plt.plot([Vinmin,Vinmax],[Vinmin,Vinmax],'k--', linewidth=lw)
plt.plot(Vinsim,Voutsim,'r')
plt.xlim(Vinmin,Vinmax)
plt.xticks(np.arange(0,2,0.2))
plt.xlabel('$V_{in}$ [$V$]')
plt.ylim(0,1.8)
plt.yticks(np.arange(0,2,0.2))
plt.ylabel('$V_{out}$ [V]')
#plt.legend(loc='best')
#textstr = '\n'.join((
#  f'$V_{{DD}} =$ {VDD:.1f} V',
#  f'$V_{{ic}} =$ {Vic:.1f} V',
#  f'$V_{{outq}} =$ {Voutq:.3f} V',
#  f'$V_{{outmax}} =$ {Voutmax:.3f} V',
#  f'$V_{{outmin}} =$ {Voutmin:.3f} V',
#  f'$V_{{swing}} =$ {Vswing:.2f} V'))
#plt.text(0.65, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
#         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

As shown in @fig-ng_cm_range, the output follows the input voltage up to about `{python} f'{Vcmmax:.2f}'` $V$. So the input common-mode voltage range is about $V_{cm,max} \cong$ `{python} f'{Vcmmax:.2f}'` $V$.

## Step-response
```{python}
Vic=0.9
DVin=10e-3
```

![Schematic of the OTA connected as a voltage follower.](Figures/Voltage_follower.png){#fig-voltage_follower}

In this section we will check the step response of the OTA operating as a voltage follower as shown in @fig-voltage_follower with its output connected to the negative input and with the same load capacitance $C_L =$ `{python} f'{CL/1e-12:.0f}'` $pF$.

### Small-step
We start by imposing a small step $\Delta V_{in} =$ `{python} f'{DVin/1e-3:.0f}'` $mV$ on top of a common mode voltage $V_{ic} =$ `{python} f'{Vic:.1f}'` $V$. The simulation results are shown in @fig-ng_step_small where $\Delta V_{in}(t) \triangleq V_{in+}(t) - V_{ic}$ and $\Delta V_{out}(t) \triangleq V_{out}(t) - V_{outq}$ with $V_{outq} \cong V_{ic}$ is the quiescent output voltage. $\Delta V_{in}$ and $\Delta V_{out}$ are compared to the response of a single pole circuit having a cut-off frequency equal to the $GBW$. The difference between the simulation an the first-order model is due to the additional poles and the zero introduced by the current mirrors and the compensation capacitor, respectively.

```{python}
#| label: fig-ng_step_small
#| fig-cap: "Step response of the OTA as a voltage follower for a small input step."

simtype = ".tran"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
simulationVoltages = simulationPath + fileName + ".ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + "1.dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + "1.ic"

V1=Vic
V2=Vic+DVin
td=0.1e-6
tr=10e-12
tf=10e-12
pw=1
per=1
nper=0

if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Ib1={Ib1/1e-9:.0f}n Ib2={Ib2/1e-6:.1f}u',
    f'.param CL={CL/1e-12:.0f}p Cc={Cc/1e-12:.1f}p',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u',
    f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u',
    f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u',
    f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u',
    f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u'
    ))
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  pulsestr = f'.param V1={V1:.3f} V2={V2:.3f} td={td:.3e} tr={tr:.3e} tf={tf:.3e} pw={pw:.3e} per={per:.3e} np={nper:.0f}'
  #print(pulsestr)
  with open(simulationPath+'pulse.par', 'w') as f:
    f.write(pulsestr)
  Nsteps=1000
  tstart=0
  tstop=1.1e-6
  tstep=(tstop-tstart)/Nsteps
  simpar = '\n'.join((
    f'.csparam tstep={tstep:.3e}',
    f'.csparam tstop={tstop:.3e}',
    f'.csparam tstart={tstart:.0f}'
    ))
  simparFile = simulationPath + "simulation.tran.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting tran simulation data file because it will be overwritten by the next tran simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)

regexp = re.compile(r'v\(out\)' + refloat)
with open(ngspiceNodeVoltageFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutqsim=float(match.group(1))

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

tsim=df_sim['time'].to_numpy()
Vinsim=df_sim['v(inp)'].to_numpy()
Voutsim=df_sim['v(out)'].to_numpy()
DVinsim=Vinsim-Vic
DVoutsim=Voutsim-Voutqsim

Npts=len(tsim)
tmin=tsim[0]
tmax=tsim[Npts-1]

#GBWthe=0.8e6
DVoutthe=np.zeros(Npts)

for k in range(0,Npts):
  if tsim[k]<td:
    DVoutthe[k]
  else:
    DVoutthe[k]=DVin*(1-exp(-2*pi*GBWthe*(tsim[k]-td)))

Adcsim=pow(10,AdcdBsim/20)
Voutfin=DVin*(1-1/Adcsim)

plt.plot([td/1e-6,(td+1/(2*pi*GBWthe))/1e-6],[0,DVin/1e-3], 'k--', linewidth=lw)
plt.plot([0,tmax/1e-6],[Voutfin/1e-3,Voutfin/1e-3], 'k--', linewidth=lw)
plt.plot(tsim/1e-6,DVinsim/1e-3,'b-', label='Input')
plt.plot(tsim/1e-6,DVoutthe/1e-3,'r--', label='Output (Theory)')
plt.plot(tsim/1e-6,DVoutsim/1e-3,'r-', label='Output (Sim.)')
plt.xlim(tmin/1e-6,tmax/1e-6)
plt.xticks(np.arange(0,1.2,0.1))
plt.xlabel('Time [$\\mu s$]')
plt.ylim(-1,12)
plt.ylabel('$\\Delta V_{in}$, $\\Delta V_{out}$ [mV]')
plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
textstr = '\n'.join((
  f'$V_{{ic}} =$ {Vic:.3f} V',
  f'$V_{{outq}} =$ {Voutqsim:.3f} V',
  f'$\\Delta V_{{in}} =$ {DVin/1e-3:.0f} mV'))
plt.text(0.65, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

### Large step
```{python}
Vic=0.9
DVin=0.3
```

We now impose a larger step $\Delta V_{in} =$ `{python} f'{DVin/1e-3:.0f}'` $mV$ on top of a common mode voltage $V_{ic} =$ `{python} f'{Vic:.1f}'` $V$. The simulation results are shown in @fig-ng_step_large where $\Delta V_{in}(t) \triangleq V_{in+}(t) - V_{ic}$ and $\Delta V_{out}(t) \triangleq V_{out}(t) - V_{outq}$ with $V_{outq} \cong V_{ic}$ is the quiescent output voltage. $\Delta V_{in}$ and $\Delta V_{out}$ are compared to the response of a single pole circuit having a cut-off frequency equal to the $GBW$. We now observe the effect of slew-rate which increases the settling time.

```{python}
#| label: fig-ng_step_large
#| fig-cap: "Step response of the OTA as a voltage follower for a large input step highlighting the slew-rate effect."

simtype = ".tran"
fileName = otaName + simtype
simulationPath = "./Simulations/ngspice/Follower/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
simulationVoltages = simulationPath + fileName + ".ic"
ngspiceDataFile = simulationPath + otaName + version + simtype + "2.dat"
ngspiceNodeVoltageFile = simulationPath + otaName + version + simtype + "2.ic"

V1=Vic
V2=Vic+DVin
td=0.1e-6
tr=10e-12
tf=10e-12
pw=1
per=1
nper=0

if newSim:
  paramstr = '\n'.join((
  f'.param VDD={VDD:.1f} Vic={Vic:.1f} Vos={Vos/1e-6:.3f}u Ib1={Ib1/1e-9:.0f}n Ib2={Ib2/1e-6:.1f}u',
  f'.param CL={CL/1e-12:.0f}p Cc={Cc/1e-12:.1f}p',
  f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u',
  f'.param W2={W2/1e-6:.2f}u L2={L2/1e-6:.2f}u',
  f'.param W3={W3/1e-6:.2f}u L3={L3/1e-6:.2f}u',
  f'.param W4={W4/1e-6:.2f}u L4={L4/1e-6:.2f}u',
  f'.param W5={W5/1e-6:.2f}u L5={L5/1e-6:.2f}u'
  ))
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  pulsestr = f'.param V1={V1:.3f} V2={V2:.3f} td={td:.3e} tr={tr:.3e} tf={tf:.3e} pw={pw:.3e} per={per:.3e} np={nper:.0f}'
  with open(simulationPath+'pulse.par', 'w') as f:
    f.write(pulsestr)
  Nsteps=1000
  tstart=0
  tstop=1.1e-6
  tstep=(tstop-tstart)/Nsteps
  simpar = '\n'.join((
    f'.csparam tstep={tstep:.3e}',
    f'.csparam tstop={tstop:.3e}',
    f'.csparam tstart={tstart:.0f}'
    ))
  simparFile = simulationPath + "simulation.tran.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting tran simulation data file because it will be overwritten by the next tran simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)

regexp = re.compile(r'v\(out\)' + refloat)
with open(ngspiceNodeVoltageFile) as f:
  for line in f:
    match = re.search(regexp, line)
    if match:
      Voutqsim=float(match.group(1))

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

tsim=df_sim['time'].to_numpy()
Vinsim=df_sim['v(inp)'].to_numpy()
Voutsim=df_sim['v(out)'].to_numpy()
DVinsim=Vinsim-Vic
DVoutsim=Voutsim-Voutqsim

Npts=len(tsim)
tmin=tsim[0]
tmax=tsim[Npts-1]

DVoutthe=np.zeros(Npts)

for k in range(0,Npts):
  if tsim[k]<td:
    DVoutthe[k]
  else:
    DVoutthe[k]=DVin*(1-exp(-2*pi*GBWthe*(tsim[k]-td)))

Adcsim=pow(10,AdcdBsim/20)
Voutfin=DVin*(1-1/Adcsim)

plt.plot([td/1e-6,(td+1/(2*pi*GBWthe))/1e-6],[0,DVin/1e-3], 'k--', linewidth=lw)
plt.plot([0,tmax/1e-6],[Voutfin/1e-3,Voutfin/1e-3], 'k--', linewidth=lw)
plt.plot(tsim/1e-6,DVinsim/1e-3,'b-', label='Input')
plt.plot(tsim/1e-6,DVoutthe/1e-3,'r--', label='Output (Theory)')
plt.plot(tsim/1e-6,DVoutsim/1e-3,'r-', label='Output (Sim.)')
plt.xlim(tmin/1e-6,tmax/1e-6)
plt.xticks(np.arange(0,1.2,0.1))
plt.xlabel('Time [$\\mu s$]')
plt.ylim(-10,320)
plt.ylabel('$\\Delta V_{in}$, $\\Delta V_{out}$ [mV]')
plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
textstr = '\n'.join((
  f'$V_{{ic}} =$ {Vic:.3f} V',
  f'$V_{{outq}} =$ {Voutqsim:.3f} V',
  f'$\\Delta V_{{in}} =$ {DVin/1e-3:.0f} mV'))
plt.text(0.65, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

## Power consumption

```{python}
Itot=2*Ib1+Ib2
P=VDD*Itot
Itele=500e-9
Ptele=Itele*VDD
```

The total power consumption without accounting for the current flowing in M~3a~ and M~5a~ is equal to $I_{tot} =$ `{python} f'{Itot/1e-6:.2f}'` $\mu A$, resulting in a total power consumption $P =$ `{python} f'{P/1e-6:.3f}'` $\mu W$. We can compare the current and power consumption of the Miller OTA to the telescopic OTA which has a current consumption of about $I_{tot,telescopic} \cong$ `{python} f'{Itele/1e-6:.1f}'` $\mu A$. The current and power consumption of the Miller OTA is `{python} f'{Itot/Itele:.2f}'` times larger than that of the telescopic OTA for the same specifications and performance. 

# Conclusion
This notebook presented the analysis, design and verification of the Miller OTA @bib:allen:book:2012 designed for a generic 180nm bulk CMOS process. The detailed analysis provided all the equations that were then used in the design phase to reach the target specifications. The design was then performed using the inversion coefficient approach with the sEKV transistor model  @bib:enz:book:2006 @bib:enz:sscmag:autumn:2017 @bib:enz:sscmag:winter:2017. The theoretical performance resulting from the design were then evaluated.

The design was then verified by simulation using ngspice @bib:ngspice:2024 with the EKV 2.6 compact model @bib:ekv2p6:doc:rev2:1998 and the parameters of a generic 180 nm bulk CMOS process. Because of the voltage at the input of the 2^nd^-stage is set by the source-to-gate voltage $V_{SG}$ of the 1^st^-stage current mirror and because the latter is higher than the source-to-gate voltage of the 2^nd^-stage transistor, the latter is driven out of saturation and the OTA output saturates to $V_{DD}$. The OTA was then simulated in closed-loop as a voltage follower in order to extract the offset voltage that is required to bring the quiescent output voltage in open-loop configuration back to the high gain region. After carefully checking the operating point, the large-signal transfer characteristic was then simulated. Then the small-signal transfer function of the OTA connected as a voltage follower was simulated. The open-loop transfer function could then be extracted from the closed-loop simulations provided some adjustment on the rather large offset voltage was done. The open-loop transfer function was then simulated making sure the OTA was biased in the high gain region. The transfer function was then compared to the theoretical estimation showing an excellent correspondance except for the DC gain which was higher for the simulated transfer function. The simulations have shown that the gain-bandwidth product $GBW$ and the DC gain are both achieved.

The input-referred noise was then simulated showing results that are very close to the theoretical estimation for both the white noise and the flicker noise. The contributions of the various transistors to the input-referred white noise were then extracted from the noise simulation and compared to the theoretical estimation. It was shown that the total white noise PSD simulation perfectly matches the theoretical estimation. The detailed contributions of the various transistors to the input-referred flicker noise was then simulated. The total input-referred flicker noise PSD also perfectly matches the theoretical estimation. It has also been shown that, despite the high value of the flicker noise cioefficient for pMOS transistors, the input-referred flicker noise is dominated by the differential pair.

The input common-mode voltage range was then simulated with the OTA connected as a voltage follower.The input voltage is limited to $V_{cm,max} =$ `{python} f'{Vcmmax:.1f}'` $V$.

Finally, the small-signal step response was simulated and succesfully compared to the response of a single-pole system. The step-response with a large input step highlighted the effect of slew-rate.

# References
