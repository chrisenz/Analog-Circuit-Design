---
title: Common-source Stage Optimization using the Inversion Coefficient
subtitle: In Closed-loop Configuration (Version 1)
author: Christian Enz (christian.enz@epfl.ch)
affiliation: EPFL
date: today
execute:
  echo: false
  warning: false
toc: true
number-sections: true
number-depth: 3
highlight-style: pygments
bibliography: references.bib
csl: ieee.csl
format: 
  html:
    include-in-header: mathjax.html
    code-fold: true
    html-math-method: mathjax
    css: styles.css
  pdf:
    keep-tex: true
    link-citations: true
    pdf-engine: pdflatex
    documentclass: scrreprt
    papersize: a4
    geometry: 
      - top=20mm
      - bottom=20mm
      - left=20mm
      - right=20mm
    include-in-header:
      text: |
        \usepackage{scrlayer-scrpage}
        \usepackage{datetime2}
        \DTMsetup{datesep=.}
        \DTMsetstyle{ddmmyyyy}
        \rohead[\thepage]{\thepage}
        \cohead[Common-source Stage Optimization using the Inversion Coefficient]{Common-source Stage Optimization using the Inversion Coefficient}
        \lofoot[$\copyright$ C. Enz]{$\copyright$ C. Enz}
        \cofoot[Analog Circuit Design]{Analog Circuit Design}
        \rofoot[\today]{\today}
---

```{python}
# Initialization

from ekv_functions import *

import pandas as pd
import matplotlib.pyplot as plt
import subprocess
import shutil
import os
import os.path as op
import sys
sys.path.append(".")
import re

from IPython.display import Markdown
from tabulate import tabulate

plt.rcParams['svg.fonttype'] = 'none'
plt.rcParams['pdf.fonttype'] = 42
plt.rcParams['font.family'] = 'Arial'
plt.rcParams['mathtext.fontset'] = 'custom'
plt.rcParams['mathtext.rm'] = 'Arial'
plt.rcParams['mathtext.it'] = 'Arial:italic'
plt.rcParams['mathtext.bf'] = 'Arial:bold'

lw=1
curvelw=1
msize=5
textFontSize=9
BodePlotParams = {'figure.figsize': (5,5)}
pltStyle='plt_style_small.mplstyle'

plt.style.use(pltStyle)

circuitName="CS_CL_optimization"
version = "_v1" # Allows you to save different versions
#newSim=True
newSim=False
refloat=r'.*?([+-]?\d+([.]\d*)?([eE][+-]?\d+)?|[.]\d+([eE][+-]?\d+)?)'
```

# Introduction

![Schematic of the common-source switched-capacitor amplifier.](Figures/CS_CL_amplifier_schematic.png){#fig-CS_CL_amplifier_schematic}

In this notebook, we want to minimize the bias current of the common-source (CS) amplifier of @fig-CS_CL_amplifier_schematic for achieving a given gain and bandwidth. Contrary to the open-loop case, the amplifier of @fig-CS_CL_amplifier_schematic is in closed-loop (CL) configuration with a capacitive feedback.

# Analysis
## Small-signal Transfer Function

![Small-signal schematic of the CS SC amplifier.](Figures/Small-signal_schematic.png){#fig-small-signal_schematic}

The small-signal schematic of the CL CS gain stage of @fig-CS_CL_amplifier_schematic is shown in @fig-small-signal_schematic. Notice that we added the input capacitance $C_{in}$ which essentially corresponds to the transistor gate-to-source and gate-to-bulk capacitances. The gate-to-drain capacitance is included in $C_F$ and therefore needs to be de-embedded in the design. It is easy to show that the transfer function is given by
\begin{equation}
  A(s) \triangleq \frac{\Delta V_{out}}{\Delta V_{in}} = A_0 \cdot \frac{1-s/\omega_z}{1+s/\omega_p}
\end{equation}
where
\begin{align}
  A_0 &= A_{0,ideal} \cdot \frac{\beta \cdot A_{dc}}{1 + \beta \cdot A_{dc}} \cong A_{0,ideal}\quad\text{for $A_{dc} \gg 1$},\\
  A_{0,ideal} &= -\frac{C_S}{C_F},\\
  \omega_p &= \frac{1+\beta \cdot A_{dc}}{R_{ds} \cdot C_{out}} \cong \frac{\beta \cdot A_{dc}}{R_{ds} \cdot C_{out}} = \frac{\beta \cdot G_m}{C_{out}},\\
  \omega_z &= \frac{G_m}{C_F}.
\end{align}

![Small-signal circuit to evaluate the feedback gain $\beta$.](Figures/Feedback_gain.png){#fig-feedback_gain}

$A_{dc} = G_m \cdot R_{ds}$ is the CS transistor DC voltage gain, $\beta \cdot A_{dc}$ the DC loop gain where $\beta$ is the feedback gain which can be calculated from the schematic shown @fig-feedback_gain as
\begin{equation}
  \beta \triangleq \frac{V}{V_{out}} = \frac{C_F}{C_F + C_S + C_{in}}.
\end{equation}

The amplifier bandwidth is given by $\omega_c = \omega_p \cong \beta \cdot G_m/C_{out}$ where $C_{out}$ is the total capacitance seen at the output and given by
\begin{equation}
  C_{out} = C_L + (1-\beta) \cdot C_F = C_L + \frac{C_S + C_{in}}{C_F + C_S + C_{in}} \cdot C_F.
\end{equation}

![Small-signal transfer function of the CL CS amplifier.](Figures/Transfer_function.png){#fig-transfer_function}

In order to achieve some DC gain, $C_F$ is made smaller than $C_S$ and usually also smaller than $C_L$. This means that the right-hand side (RHS) zero is located higher than the unity gain frequency which is then simply given by $\omega_u \cong G_m/C_{out}$. For frequencies below $\omega_u$, the magnitude of the transfer function is shown in @fig-transfer_function.

## Minimum current for a given bandwidth (long-channel)
When optimizing the CL CS amplifier for low current consumption, the transistor is often biased in moderate or even weak inversion leading to large transistor and therefore an increased input and output capacitance. If we assume that the transistor parasitic capacitance at the drain is much smaller than the load capacitance, we can neglect its impact on the output capacitance. On the other hand, twe input capacitance can be modeled as the sum of the gate-to-source and gate-to-bulk capacitances
\begin{equation}
  C_{in} = C_{GS} + C_{GB}.
\end{equation}
Assuming that the transistor is biased in saturation, we have
\begin{equation}
  C_{GS} \cong W\,L\,C_{ox} \cdot c_{gsi} + C_{GSo} \cdot W
\end{equation}
where $c_{gsi}$ is the normalized intrinsic gate-to-source capacitance which is typically equal to $2/3$ in strong inversion and is proportional to $IC$ in weak inversion. $C_{GSo}$ is the gate-to-source overlap capacitance per unit width.

The gate-to-bulk capacitance $C_{GB}$ is given by
\begin{equation}
  C_{GB} \cong \,W\,L\,C_{ox} \cdot c_{gbi} + C_{GBo} \cdot W,
\end{equation}
where $c_{gbi}$ is the normalized gate-to-bulk intrinsic capacitance which in strong inversion is given by
\begin{equation}
  c_{gbi} = \frac{n-1}{3n}.
\end{equation}
$C_{GBo}$ is the gate-to-bulk overlap capacitance per unit width.

For a given transistor length $L$, the input capacitance $C_{in}$ scales with $W$ according to
\begin{equation}
  C_{in} = C_{GW} \cdot W,
\end{equation}
where $C_{GW}$ is the gate-to-source and gate-to-bulk capacitance per unit width given by
\begin{equation}
  C_{GW} = L\,C_{ox} \cdot (c_{gsi} + c_{gbi}) + C_{GSo}  + C_{GBo}.
\end{equation}

In order to achieve a certain bandwidth we need to have a certain transconductance for a certain load capacitance. In order to maximize the current efficiency, we should bias the transistor in weak inversion. This leads to a large transistor and therefore large parasitic capacitances which will impact the bandwidth. Imposing the bandwidth, at some point the capacitance becomes so large that it is no more possible to achieve the required transconductance in weak inversion for the desired bandwidth. Does this mean that there is a minimum current for the CL CS amplifier to achieve a certain bandwidth?

To answer this question we need to solve the following set of equations for $I_b$ and $W$ assuming a given length $L$
\begin{align}
  \omega_c &= \beta \cdot \frac{G_m}{C_{out}},\\
  C_{out} &= C_L + (1-\beta) \cdot C_F,\\
  \beta &= \frac{C_F}{C_F + C_S + C_{in}},\\
  C_{in} &= W \cdot C_{GW},\\
  I_b &= I_{spec\Box} \cdot \frac{W}{L} \cdot IC,\\
  G_m &= \frac{I_{spec\Box}}{n U_T} \cdot \frac{W}{L} \cdot g_{ms}(IC),
\end{align}
where $g_{ms}(IC)$ is the long-channel normalized source transconductance given by
\begin{equation}
  g_{ms} \triangleq \frac{G_{ms}}{G_{spec}} = \frac{G_{ms}\,U_T}{I_{spec}} = \frac{G_m\,n U_T}{I_{spec}}= \frac{\sqrt{4 IC + 1} - 1}{2} = \frac{2 IC}{\sqrt{4 IC + 1} + 1}.
\end{equation}
with $I_{spec} = I_{spec\Box}\,W/L$.

Solving for $I_b$ and $W/L$ leads to the following normalized solutions
\begin{align}\label{eq:ib_AR}
  i_b &\triangleq \frac{I_b}{I_{spec\Box} \cdot \Omega} = \frac{IC}{g_{ms}(IC) - \Theta},\\
  AR &\triangleq \frac{W/L}{\Omega} =\frac{1}{g_{ms} - \Theta},
\end{align}
where
\begin{align}
  \Omega &\triangleq \frac{\omega_c}{\omega_L},\\
  \omega_L &\triangleq \frac{I_{spec\Box}}{n U_T} \cdot \frac{1}{(1+C_S/C_L+C_S/C_F) \cdot C_L},\\
  \Theta &\triangleq \frac{\omega_c}{\omega_W},\\
  \omega_W &\triangleq \frac{I_{spec\Box}}{n U_T} \cdot \frac{1}{(1+C_L/C_F) \cdot C_{GW} \cdot L}.
\end{align}

::: {.callout-note}
Notice that we get the same equations for the normalized current $i_b$ and normalized aspect ratio $AR$ than what we obtained for the CS in open-loop configuration. Except that the normalization is now different.
:::

The normalized current $i_b$ and aspect ratio $AR$ are plotted versus the inversion coefficient $IC$ in @fig-ib_ar_vs_ic_self_loading for different values of parameter $\Theta$. The normalized current $i_b$ is also plotted versus the inversion coefficient for more values of parameter $\Theta$ in @fig-ib_vs_ic.

```{python}
#| label: fig-ib_ar_vs_ic_self_loading
#| fig-cap: Normalized bias current $i_b$ anbd aspect ratio $AR$ versus inversion coefficient $IC$.

# Normalized bias current versus IC of CS stage including self-loading
def ib_ic_long(ic,theta):
    IClim=theta*(1+theta)
    if ic<IClim:
        ib=float("nan")
    else:
        gms=gms_ic(ic)
        ib=ic/(gms-theta)
    return ib

# Normalized aspect ratio versus IC of CS stage including self-loading
def ar_ic_long(ic,theta):
    IClim=theta*(1+theta)
    if ic<IClim:
        ar=float("nan")
    else:
        gms=gms_ic(ic)
        ar=1/(gms-theta)
    return ar

# Optimum IC of CS stage including self-loading
def ICopt_theta(theta):
    return (sqrt(theta*(1+theta))+theta+0.5)**2-0.25

# Normalized ib versus IC of CS stage including self-loading
def ibopt_theta(theta):
    return 1+2*theta+2*sqrt(theta*(1+theta))

Npts=1001
logICmin=-2
logICmax=2
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
IC=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)
ib0=np.zeros(Npts)
ib0si=np.zeros(Npts)
ib1=np.zeros(Npts)
ib2=np.zeros(Npts)
ar0=np.zeros(Npts)
ar0si=np.zeros(Npts)
ar1=np.zeros(Npts)
ar2=np.zeros(Npts)
theta=[0,0.03,0.1]
thetaopt=np.logspace(-4,1,Npts,endpoint=True,base=10.0)
ICopt=np.zeros(Npts)
ibopt=np.zeros(Npts)
Ncurves=len(theta)
ICop=np.zeros(Ncurves)
ibop=np.zeros(Ncurves)

for m in range(1,Ncurves):
    ICop[m]=ICopt_theta(theta[m])
    ibop[m]=ibopt_theta(theta[m])

for k in range(0,Npts):
    ib0[k]=ib_ic_long(IC[k],theta[0])
    ib0si[k]=sqrt(IC[k])
    ib1[k]=ib_ic_long(IC[k],theta[1])
    ib2[k]=ib_ic_long(IC[k],theta[2])
    ar0[k]=ar_ic_long(IC[k],theta[0])
    ar0si[k]=1/sqrt(IC[k])
    ar1[k]=ar_ic_long(IC[k],theta[1])
    ar2[k]=ar_ic_long(IC[k],theta[2])
    ICopt[k]=ICopt_theta(thetaopt[k])
    ibopt[k]=ibopt_theta(thetaopt[k])

fig, ax1 = plt.subplots()
ax2 = ax1.twinx()
ax1.loglog(ICop,ibop,'ro', markersize=msize)
ax1.loglog(IC,ib0si,'k--',linewidth=lw)
ax1.loglog([theta[1],theta[1]],[1e-1,1e2],'k--',linewidth=lw)
ax1.loglog([theta[2],theta[2]],[1e-1,1e2],'k--',linewidth=lw)
ax1.loglog(IC,ib0,'r-')
ax1.loglog(IC,ib1,'r-')
ax1.loglog(IC,ib2,'r-')
ax1.loglog(ICopt,ibopt,'r--')
ax1.set_xlabel('Inversion Coefficient $IC$')
ax1.set_xlim(ICmin,ICmax)
ax1.set_ylabel('Normalized bias current $i_b$')
ax1.set_ylim(0.1,100)
ax1.annotate('$\\Theta=$' + f'{theta[0]:.0f}', size=textFontSize,
             xy=(0.017, ib_ic_long(0.017,theta[0])), xycoords='data',
             xytext=(0, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
            ha='center', va='top')
ax1.annotate('$\\Theta=$' + f'{theta[1]:.2f}', size=textFontSize,
             xy=(0.08, ib_ic_long(0.08,theta[1])), xycoords='data',
             xytext=(0, -35), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
ax1.annotate('$\\Theta=$' + f'{theta[2]:.1f}', size=textFontSize,
             xy=(0.3, ib_ic_long(0.3,theta[2])), xycoords='data',
             xytext=(0, -35), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
ax1.annotate('', xy=(10, 80), xycoords='axes points',
             xytext=(20, 0), textcoords='offset points',
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, linewidth=3, capstyle='butt', ec='r', fc='r', joinstyle='miter'))
ax1.text(30, 80, '$\\lambda_c = 0$', ha='center', va='top', size=textFontSize,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

ax2.loglog(IC,ar0si,'k--',linewidth=lw)
ax2.loglog(IC,ar0,'b-')
ax2.loglog(IC,ar1,'b-')
ax2.loglog(IC,ar2,'b-')
ax2.set_ylabel('Normalized $W/L$ $AR$', va='bottom', rotation=270)
ax2.set_ylim(0.1,100)
ax2.annotate('$\\Theta=$' + f'{theta[0]:.0f}', size=textFontSize,
             xy=(0.017, ar_ic_long(0.017,theta[0])), xycoords='data',
             xytext=(0, -30), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
ax2.annotate('$\\Theta=$' + f'{theta[1]:.2f}', size=textFontSize,
             xy=(0.08, ar_ic_long(0.08,theta[1])), xycoords='data',
             xytext=(20, 20), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='left', va='bottom')
ax2.annotate('$\\Theta=$' + f'{theta[2]:.1f}', size=textFontSize,
             xy=(0.22, ar_ic_long(0.22,theta[2])), xycoords='data',
             xytext=(20, 20), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='left', va='bottom')
ax2.annotate('', xy=(210, 30), xycoords='axes points',
             xytext=(-20, 0), textcoords='offset points',
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, linewidth=3, capstyle='butt', ec='b', fc='b', joinstyle='miter'))
plt.show()
```


```{python}
#| label: fig-ib_vs_ic
#| fig-cap: Normalized bias current $i_b$ versus inversion coefficient $IC$.

def ICopt_theta(theta):
    return (sqrt(theta*(1+theta))+theta+0.5)**2-0.25

def ibopt_theta(theta):
    return 1+2*theta+2*sqrt(theta*(1+theta))

Npts=1001
thetaopt=np.logspace(-4,1,Npts,endpoint=True,base=10.0)
ICopt=np.zeros(Npts)
ibopt=np.zeros(Npts)

for k in range(0,Npts):
    ICopt[k]=ICopt_theta(thetaopt[k])
    ibopt[k]=ibopt_theta(thetaopt[k])

plt.loglog(ICopt,ibopt,'r--')

theta=[0,0.01,0.03,0.1,0.3,1]

Ncurves=len(theta)
IClim=np.zeros(Ncurves)
colors=plt.cm.rainbow(np.linspace(0, 1, Ncurves))
logICmin=-2
logICmax=2
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
IC=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)

ib=np.zeros(Npts)

for m in range(0,Ncurves):
    IClim[m]=theta[m]*(1+theta[m])
    ICop=ICopt_theta(theta[m])
    ibop=ibopt_theta(theta[m])
    for k in range(0,Npts):
        if IC[k]<IClim[m]:
            ib[k]=float("nan")
        else:
            ib[k]=IC[k]/(gms_ic(IC[k])-theta[m])
    plt.loglog([IClim[m],IClim[m]],[1,1e2],'k--', linewidth=lw)
    plt.loglog(IC, ib, color=colors[m], label='$\\Theta =$' + f'{theta[m]:.2f}')
    plt.loglog(ICop,ibop,'ro', markersize=msize)

plt.loglog([1,1e2],[1,1e1],'k--', linewidth=lw)
plt.xlim(ICmin,ICmax)
#plt.xticks(np.arange(0,11,1))
plt.xlabel('$IC$')
plt.ylim(1,1e2)
#plt.yticks(np.arange(0,1.1,0.1))
plt.ylabel('Normalized bias current $i_b$')
#plt.legend(loc='lower right')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.text(0.7, 0.95, 'No VS ($\\lambda_c = 0$)', ha='left', va='top', size=textFontSize, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

From @fig-ib_ar_vs_ic_self_loading and @fig-ib_vs_ic, we clearly see that there is a minimum current for a given value of parameter $\Theta$. We can find the optimum inversion coefficient $IC_{opt}$ corresponding to this minimum current which is given by
\begin{align}
  IC_{opt} &= \left(\sqrt{\Theta \cdot (1+\Theta)} + \Theta + \frac{1}{2}\right)^2 - \frac{1}{4}\\
  &= 2 \Theta \cdot (1+\Theta) + (1+2\Theta) \cdot \sqrt{\Theta \cdot (1+\Theta)}\\
  &\cong 2 \Theta + \sqrt{\Theta} \;\; \textsf{for $\Theta \ll 1$}.
\end{align}
We also see that there is a minimum inversion coefficient $IC_{lim}$ below which the desired bandwidth $\omega_c$ can no more be achieved
\begin{equation}
  IC_{lim} = \Theta \cdot (1+\Theta) \cong \Theta,
\end{equation}
which is about equal to $\Theta$ for small values of $\Theta$.

The optimum normalized current is given by
\begin{equation}
  i_{bopt} \triangleq i_b(IC_{opt}) = 1 + 2\Theta +2\sqrt{\Theta \cdot (1+\Theta)}.
\end{equation}

The optimum current also corresponds to an optimum transistor width $W$ and hence and optimum normalized $W/L$ given by
\begin{equation}
  AR_{opt} \triangleq AR(IC_{opt}) = \frac{1}{\sqrt{\Theta \cdot (1+\Theta)}}.
\end{equation}

```{python}
#| label: fig-ar_vs_ic
#| fig-cap: Normalized aspect ratio $W/L$ versus inversion coefficient $IC$.

def ARopt_theta(theta):
    if theta==0:
        ARopt=float("nan")
    else:
        ARopt=1/sqrt(theta*(1+theta))
    return ARopt

Npts=1001
thetaopt=np.logspace(-4,1,Npts,endpoint=True,base=10.0)
ICopt=np.zeros(Npts)
ARopt=np.zeros(Npts)

for k in range(0,Npts):
    ICopt[k]=ICopt_theta(thetaopt[k])
    ARopt[k]=ARopt_theta(thetaopt[k])

plt.loglog(ICopt,ARopt,'r--')

theta=[0,0.01,0.03,0.1,0.3,1]

Ncurves=len(theta)
IClim=np.zeros(Ncurves)
colors=plt.cm.rainbow(np.linspace(0, 1, Ncurves))
logICmin=-2
logICmax=2
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
IC=np.logspace(logICmin,logICmax,Npts,endpoint=True,base=10.0)

AR=np.zeros(Npts)

for m in range(0,Ncurves):
    IClim[m]=theta[m]*(1+theta[m])
    ICop=ICopt_theta(theta[m])
    ARop=ARopt_theta(theta[m])
    for k in range(0,Npts):
        if IC[k]<IClim[m]:
            AR[k]=float("nan")
        else:
            AR[k]=1/(gms_ic(IC[k])-theta[m])
    plt.loglog([IClim[m],IClim[m]],[1e-1,1e2],'k--', linewidth=lw)
    plt.loglog(IC, AR, color=colors[m], label='$\\Theta =$' + f'{theta[m]:.2f}')
    plt.loglog(ICop,ARop,'ro', markersize=msize)

plt.loglog([1e-2,1],[1e2,1],'k--', linewidth=lw)
plt.loglog([1,1e2],[1,1e-1],'k--', linewidth=lw)
plt.xlim(ICmin,ICmax)
#plt.xticks(np.arange(0,11,1))
plt.xlabel('$IC$')
plt.ylim(1e-1,1e2)
#plt.yticks(np.arange(0,1.1,0.1))
plt.ylabel('Normalized $W/L$')
#plt.legend(loc='lower right')
plt.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.text(0.7, 0.95, 'No VS ($\\lambda_c = 0$)', ha='left', va='top', size=textFontSize, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

We see from @fig-ar_vs_ic that the transistor width increases first as $1/\sqrt{IC}$ in strong inversion and then as $1/IC$ in weak inversion making the transistor quickly very large until $IC$ reaches $IC_{lim}$ where the width becomes infinity. The dots correspond to the $AR$ obtained for $IC_{opt}$.

The optimum parameters $IC_{opt}$, $i_{bopt}$ and $AR_{opt}$ are plotted versus $\Theta$ in @fig-icopt_ibopt_aropt_vs_theta. We can see that the optimum inversion coefficient is always located in moderate or eventually weak inversion.

```{python}
#| label: fig-icopt_ibopt_aropt_vs_theta
#| fig-cap: Optimum parameters versus $\Theta$.

from matplotlib.patches import Rectangle

def ICopt_theta(theta):
    return (sqrt(theta*(1+theta))+theta+0.5)**2-0.25

def ibopt_theta(theta):
    return 1+2*theta+2*sqrt(theta*(1+theta))

def ARopt_theta(theta):
    if theta==0:
        ARopt=float("nan")
    else:
        ARopt=1/sqrt(theta*(1+theta))
    return ARopt

Npts=101
logthetamin=-3
logthetamax=0
thetamin=pow(10,logthetamin)
thetamax=pow(10,logthetamax)
theta=np.logspace(logthetamin,logthetamax,Npts,endpoint=True,base=10.0)

ICopt=np.zeros(Npts)
ibopt=np.zeros(Npts)
ARopt=np.zeros(Npts)

for k in range(0,Npts):
    ICopt[k]=ICopt_theta(theta[k])
    ibopt[k]=ibopt_theta(theta[k])
    ARopt[k]=ARopt_theta(theta[k])

plt.loglog(theta, ICopt, 'r-', label='$IC_{opt}$')
plt.loglog(theta, ibopt, 'b-', label='$i_{bopt}$')
plt.loglog(theta, ARopt, 'g-', label='$AR_{opt}$')
plt.xlim(thetamin,thetamax)
#plt.xticks(np.arange(0,11,1))
plt.xlabel('$\\Theta$')
plt.ylim(1e-2,1e2)
#plt.yticks(np.arange(0,1.1,0.1))
plt.ylabel('$IC_{opt}$, $i_{bopt}$, $AR_{opt}$')
plt.legend(loc='lower right')
#plt.legend(loc='center left', fontsize=14, bbox_to_anchor=(1, 0.5))
plt.text(0.7, 0.95, 'No VS ($\\lambda_c = 0$)', ha='left', va='top', size=textFontSize, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
currentAxis = plt.gca()
currentAxis.add_patch(Rectangle((1e-3, 1e-1), 1-1e-3, 1e1-1e-1, facecolor='0.9'))
plt.show()
```

# Design Example

![Schematic of the CS SC amplifier used for simulations.](Figures/Example_schematic.png){#fig-example_schematic}

We want to size a CS SC amplifier for the specifications given in @tbl-specs. We need to find the minimum current and size the transistor to achieve this specs. We will design the amplifier for a generic 180nm bulk CMOS process. The physical parameters are given in @tbl-physics_param, the global process parameters in @tbl-process_param and finally the MOSFET parameters in @tbl-mos_param. 

Note that the feedback resistor $R_F$ in @fig-example_schematic has been added for biasing purpose and should be taken large enough not to limit the gain and bandwidth. The cut-off frequency due to $R_F$ is given by
\begin{equation}
  \omega_l = \frac{A_0}{R_F \cdot C_S}
\end{equation}
from which we deduce the value of $R_F$
\begin{equation}
  R_F = \frac{A_0}{\omega_l \cdot C_S}.
\end{equation}
We will set $f_l$ to 1 Hz.

```{python}
#| label: tbl-specs
#| tbl-cap: CS SC amplifier specifications.

from specs import *

table = [["DC gain","$A_0$",f'{A0dB:.0f}',"$dB$"],
         ["Bandwidth","$BW$",f'{BW/1e3:.0f}',"$kHz$"],
         ["Load capacitance","$C_L$",f'{CL/1e-12:.0f}',"$pF$"],
         ["Feedback capacitance","$C_F$",f'{CF/1e-15:.0f}',"$fF$"],
         ["Transistor length","$L$",f'{L/1e-6:.0f}',"$\\mu m$"]
         ]
Markdown(tabulate(
  table,
  headers=["Specification","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center")
))
```

## Process
We will design the CS CL amplifier for generic 180nm bulk CMOS process. The physical parameters are given in @tbl-physics_param, the global process parameters in @tbl-process_param and finally the MOSFET parameters in @tbl-mos_param. 

```{python}
#| label: tbl-physics_param
#| tbl-cap: Physical parameters

from tsmc018_sekv_ekv2p6 import *

table = [["$T$",f'{T:.0f}',"$K$"],
         ["$U_T$",f'{UT/1e-3:.3f}',"$mV$"]
         ]
Markdown(tabulate(
  table,
  headers=["Parameter","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center", "center", "center")
))
```

```{python}
#| label: tbl-process_param
#| tbl-cap: Global process parameters

from tsmc018_sekv_ekv2p6 import *

table = [["$V_{DD}$",f'{VDD:.1f}',"$V$"],
         ["$C_{ox}$",f'{Cox*1e3:.3f}',"$\\frac{fF}{\\mu m^2}$"],
         ["$W_{min}$",f'{Wmin/1e-9:.0f}',"$nm$"],
         ["$L_{min}$",f'{Lmin/1e-9:.0f}',"$nm$"]
         ]
Markdown(tabulate(
  table,
  headers=["Parameter","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center", "center", "center")
))
```

```{python}
#| label: tbl-mos_param
#| tbl-cap: Transistor process parameters

from tsmc018_sekv_ekv2p6 import *

table = [["sEKV parameters"],
         ["$n$",f'{n0n:.2f}',f'{n0p:.2f}',"-"],
         ["$I_{{spec\\Box}}$",f'{Ispecsqn/1e-9:.0f}',f'{Ispecsqp/1e-9:.0f}',"$nA$"],
         ["$V_{{T0}}$",f'{VT0n:.3f}',f'{VT0p:.3f}',"$V$"],
         ["$L_{{sat}}$",f'{Lsatn/1e-9:.0f}',f'{Lsatp/1e-9:.0f}',"$nm$"],
         ["$\\lambda$",f'{lambdan*1e-6:.0f}',f'{lambdap*1e-6:.0f}',"$\\frac{{V}}{{\\mu m}}$"],
         ["Overlap capacitances parameters"],
         ["$C_{{GDo}}$",f'{CGDOn*1e9:.3f}',f'{CGDOp*1e9:.3f}','$\\frac{{fF}}{{\\mu m}}$'],
         ["$C_{{GSo}}$",f'{CGSOn*1e9:.3f}',f'{CGSOp*1e9:.3f}','$\\frac{{fF}}{{\\mu m}}$'],
         ["$C_{{GBo}}$",f'{CGBOn*1e9:.3f}',f'{CGBOp*1e9:.3f}','$\\frac{{fF}}{{\\mu m}}$'],
         ["Junction capacitances parameters"],
         ["$C_J$",f'{CJn*1e3:.3f}',f'{CJp*1e3:.3f}','$\\frac{{fF}}{{\\mu m^2}}$'],
         ["$C_{{JSW}}$",f'{CJSWn*1e9:.3f}',f'{CJSWp*1e9:.3f}','$\\frac{{fF}}{{\\mu m}}$'],
         ["Flicker noise parameters"],
         ["$K_F$",f'{KFn:.1e}',f'{KFn:.1e}',"$J$"],
         ["$AF$",f'{AFn:.1f}',f'{AFp:.1f}',"-"],
         ["$\\rho$",f'{rhon:.3e}',f'{rhop:.3e}','$\\frac{{V \\cdot m^2}}{{A \\cdot s}}$'],
         ["Matching parameters"],
         ["$A_{{VT}}$",f'{AVTn*1e9:.0f}',f'{AVTp*1e9:.0f}',"$mV \\cdot \\mu m$"],
         ["$A_{{\\beta}}$",f'{Abetan*1e8:.0f}',f'{Abetap*1e8:.0f}',"$\\% \\cdot \\mu m$"],
         ["Source and drain sheet resistance parameter"],
         ["$R_{{sh}}$",f'{RSHn:.0f}',f'{RSHp:.0f}',"$\\frac{{\\Omega}}{{\\mu m}}$"],
         ["Width and length parameters"],
         ["$\\Delta W$",f'{DWn/1e-9:.0f}',f'{DWp/1e-9:.0f}',"$\\,nm$"],
         ["$\\Delta L$",f'{DLn/1e-9:.0f}',f'{DLp/1e-9:.0f}',"$\\,nm$"]
         ]
Markdown(tabulate(
  table,
  headers=["Parameter","NMOS","PMOS","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center", "center", "center")
))
```

We first need to estimate the parameter $C_{GW}$ which is related to the transistor input capacitance $C_{in}$. Since we don't know the inversion coefficient we cannot estimate $c_{gsi}$ and $c_{gbi}$. We therefore will take their values in strong inversion for the estimation of the input capacitance per width $C_{GW}$
\begin{equation}
  C_{GW} \cong \left(1-\frac{1}{3 n}\right) \cdot C_{ox} \cdot L + C_{GSo} + C_{GBo},
\end{equation}
which depends on transistor length $L$. Since the above theory was developed for a long-channel device, we will choose $L =$ `{python} f'{L/1e-6:.0f}'` $\mu m$. We can now estimate the total gate capacitance per unit width for an n-channel transistor. 

```{python}
CGW=(1-1/(3*n0n))*Cox*L+CGSOn+CGBOn
A0=pow(10,A0dB/20)
CS=A0*CF
```

For the selected technology, we get $C_{GW} =$ `{python} f'{CGW/1e-9:.3f}'` $fF/\mu m$.

From the DC gain specification $A_0 =$ `{python} f'{A0:.0f}'`, we get $C_S =$ `{python} f'{CS/1e-12:.0f}'` $pF$. We can compute the optimum inversion coefficient $IC_{opt}$, optimum width $W_{opt}$, optimum current $I_{b,opt}$ and aspect ratio $\left.W/L\right|_{opt}$ which are given in @tbl-optimum_parameters.

```{python}
#| label: tbl-optimum_parameters
#| tbl-cap: CS CL amplifier optimum parameters.

def ICopt_theta(theta):
    return (sqrt(theta*(1+theta))+theta+0.5)**2-0.25

def ibopt_theta(theta):
    return 1+2*theta+2*sqrt(theta*(1+theta))

def ARopt_theta(theta):
    return 1/sqrt(theta*(1+theta))

nUT=n0n*UT
fc=BW
wc=2*pi*fc
GBW=A0*fc
wL=Ispecsqn/((1+CS/CL+CS/CF)*CL*nUT)
wW=Ispecsqn/((1+CL/CF)*CGW*L*nUT)
Omega=wc/wL
theta=wc/wW
ICopt=ICopt_theta(theta)
ibopt=ibopt_theta(theta)
ARopt=ARopt_theta(theta)
Ibopt=ibopt*Ispecsqn*Omega
WoverLopt=ARopt*Omega
Wopt=WoverLopt*L
Cin=CGW*Wopt
CGD=Wopt*CGDOn
CF0=CF-CGD
fl=10
wl=2*pi*fl
RF=A0/(wl*CS)

table = [["$A_0$",f'{A0:.3f}',"-"],
         ["$C_S$",f'{CS/1e-12:.3f}',"$pF$"],
         ["$f_L$",f'{wL/(2*pi*1e3):.3f}',"$kHz$"],
         ["$f_W$",f'{wW/(2*pi*1e6):.3f}',"$MHz$"],
         ["$\\Omega$",f'{Omega:.3f}',"-"],
         ["$\\theta$",f'{theta:.3e}',"-"],
         ["$IC_{opt}$",f'{ICopt:.3f}',"-"],
         ["$i_{b,opt}$",f'{ibopt:.3f}',"-"],
         ["$AR_{opt}$",f'{ARopt:.3f}',"-"],
         ["$\\left(\\frac{W}{L}\\right)_{opt}$",f'{WoverLopt:.3f}',"-"],
         ["$I_{b,opt}$",f'{Ibopt/1e-9:.0f}',"$nA$"],
         ["$W_{opt}$",f'{Wopt/1e-6:.2f}',"$\\mu m$"],
         ["$C_{in}$",f'{Cin/1e-15:.3f}',"$fF$"],
         ["$C_{GD}$",f'{CGD/1e-15:.3f}',"$fF$"],
         ["$C_F$",f'{CF/1e-15:.3f}',"$fF$"],
         ["$C_{F0}$",f'{CF0/1e-15:.3f}',"$fF$"],
         ["$R_F$",f'{RF/1e12:.3f}',"$T \\Omega$"]
        ]

Markdown(tabulate(
  table,
  headers=["Parameter","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("center", "center", "center")
))
```

```{python}
#| label: tbl-transistor_info1
#| tbl-cap: Transistor size and bias information.

transistor_info={
    "Type": ["n"],
    "W": [Wopt],
    "L": [L],
    "ID": [Ibopt]
}
transistor_list=["M1"]
ekvmos_df=pd.DataFrame(transistor_info, index=transistor_list)

ekvmos_df["W/L"]=ekvmos_df["W"]/ekvmos_df["L"]
ekvmos_df["Ispec"]=np.where(ekvmos_df["Type"]=="n",
                                     ekvmos_df["W/L"]*Ispecsqn,
                                     ekvmos_df["W/L"]*Ispecsqp)
ekvmos_df["IC"]=ekvmos_df["ID"]/ekvmos_df["Ispec"]
ekvmos_df["VP-VS"]=UT*vps_ic(ekvmos_df["IC"])
ekvmos_df["n"]=np.where(ekvmos_df["Type"]=="n",
                                     n0n,
                                     n0p)
ekvmos_df["VG-VT0"]=np.where(ekvmos_df["Type"]=="n",
                                     ekvmos_df["VP-VS"]/n0n,
                                     ekvmos_df["VP-VS"]/n0p)
ekvmos_df["VDSsat"]=UT*vdssat_ic(ekvmos_df["IC"])
ekvmos_df["Gspec"]=ekvmos_df["Ispec"]/UT
ekvmos_df["Gms"]=ekvmos_df["Gspec"]*gms_ic(ekvmos_df["IC"])
ekvmos_df["Gm"]=np.where(ekvmos_df["Type"]=="n",
                                     ekvmos_df["Gms"]/n0n,
                                     ekvmos_df["Gms"]/n0p)
ekvmos_df["Gds"]=np.where(ekvmos_df["Type"]=="n",
                                     ekvmos_df["ID"]/(lambdan*ekvmos_df["L"]),
                                     ekvmos_df["ID"]/(lambdap*ekvmos_df["L"]))
ekvmos_df["gamman"]=np.where(ekvmos_df["Type"]=="n",
                                     gamman_ic(ekvmos_df["IC"],n0n),
                                     gamman_ic(ekvmos_df["IC"],n0p))
ekvmos_df["COX"]=Cox*ekvmos_df["W"]*ekvmos_df["L"]
ekvmos_df["CGSi"]=ekvmos_df["COX"]*cgsi_ic(ekvmos_df["IC"])
ekvmos_df["CGDi"]=0
ekvmos_df["CGBi"]=np.where(ekvmos_df["Type"]=="n",
                                     ekvmos_df["COX"]*cgbi_ic(ekvmos_df["IC"],n0n),
                                     ekvmos_df["COX"]*cgbi_ic(ekvmos_df["IC"],n0p))
ekvmos_df["CBSi"]=np.where(ekvmos_df["Type"]=="n",
                                     ekvmos_df["COX"]*cbsi_ic(ekvmos_df["IC"],n0n),
                                     ekvmos_df["COX"]*cbsi_ic(ekvmos_df["IC"],n0p))
ekvmos_df["CBDi"]=np.where(ekvmos_df["Type"]=="n",
                                     ekvmos_df["CGDi"]*(n0n-1),
                                     ekvmos_df["CGDi"]*(n0p-1))
ekvmos_df["CGSe"]=np.where(ekvmos_df["Type"]=="n",
                                     ekvmos_df["W"]*CGSOn,
                                     ekvmos_df["W"]*CGSOp)
ekvmos_df["CGDe"]=np.where(ekvmos_df["Type"]=="n",
                                     ekvmos_df["W"]*CGDOn,
                                     ekvmos_df["W"]*CGDOp)
ekvmos_df["CGBe"]=np.where(ekvmos_df["Type"]=="n",
                                    ekvmos_df["W"]*CGBOn,
                                    ekvmos_df["W"]*CGBOp)
ekvmos_df["CBSe"]=np.where(ekvmos_df["Type"]=="n",
                                    ekvmos_df["W"]*ekvmos_df["L"]*CJn+2*(ekvmos_df["W"]+ekvmos_df["L"])*CJSWn,
                                    ekvmos_df["W"]*ekvmos_df["L"]*CJp+2*(ekvmos_df["W"]+ekvmos_df["L"])*CJSWp)
ekvmos_df["CBDe"]=np.where(ekvmos_df["Type"]=="n",
                                    ekvmos_df["W"]*ekvmos_df["L"]*CJn+2*(ekvmos_df["W"]+ekvmos_df["L"])*CJSWn,
                                    ekvmos_df["W"]*ekvmos_df["L"]*CJp+2*(ekvmos_df["W"]+ekvmos_df["L"])*CJSWp)
ekvmos_df["CGS"]=ekvmos_df["CGSi"]+ekvmos_df["CGSe"]
ekvmos_df["CGD"]=ekvmos_df["CGDi"]+ekvmos_df["CGDe"]
ekvmos_df["CGB"]=ekvmos_df["CGBi"]+ekvmos_df["CGBe"]
ekvmos_df["CBS"]=ekvmos_df["CBSi"]+ekvmos_df["CBSe"]
ekvmos_df["CBD"]=ekvmos_df["CBDi"]+ekvmos_df["CBDe"]
#pd.set_option('display.float_format', '{:.2E}'.format)
#ekvmos_df

# Generate the table from dataframe
feature_list=["W","L","ID","Ispec","IC","VG-VT0","VDSsat"]
Nmos=len(transistor_list)
Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(ekvmos_df.at[mos,feature])
  table.append(row)

# Scale data for proper units
for i in range(Nmos):
  for j in [1,2]:
    table[i][j]=table[i][j]/1e-6
  for j in [3,4]:
    table[i][j]=table[i][j]/1e-9
  for j in [6,7]:
    table[i][j]=table[i][j]/1e-3

Markdown(tabulate(
  table,
  headers=["Transistor","$W\\;[\\mu m]$","$L\\;[\\mu m]$","$I_D\\;[nA]$","$I_{{spec}}\\;[nA]$","$IC$","$V_G-V_{{T0}}\\;[mV]$","$V_{{DSsat}}\\;[mV]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center","center","center"),
  floatfmt=(".3f",".2f",".2f",".0f",".0f",".3f",".0f",".0f")
))
```


```{python}
#| label: tbl-transistor_info2
#| tbl-cap: Transistor small-signal and thermal noise parameters.

# Generate the table from dataframe
feature_list=["Gspec","Gms","Gm","Gds","gamman"]
Nmos=len(transistor_list)
Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(ekvmos_df.at[mos,feature])
  table.append(row)

# Scale data for proper units
for i in range(Nmos):
  for j in [1,2,3]:
    table[i][j]=table[i][j]/1e-6
  for j in [4]:
    table[i][j]=table[i][j]/1e-9

Markdown(tabulate(
  table,
  headers=["Transistor","$G_{{spec}}\\;[\\mu A/V]$","$G_{{ms}}\\;[\\mu A/V]$","$G_m\\;[\\mu A/V]$","$G_{{ds}}\\;[nA/V]$","$\\gamma_n$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center"),
  floatfmt=(".3f",".3f",".3f",".3f",".3f",".3f")
))
```

The transistor size and bias information are given in @tbl-transistor_info1, while @tbl-transistor_info2 gives the small-signal parameters.

Having all the parameters, we can now calculate the theoretical transfer function which is plotted in @fig-theoretical_tf. We see that the DC gain and bandwidth are achieved.

```{python}
#| label: fig-theoretical_tf
#| fig-cap: Theoretical transfer function.

def Av(s,Adc,wp,wz):
    num=Adc*(1-s/wz)
    den=1+s/wp
    return num/den

Gmthe=ekvmos_df.at['M1','Gm']
Gdsthe=ekvmos_df.at['M1','Gds']
Adcthe=Gmthe/Gdsthe
A0ide=CS/CF
A0dBide=20*log(abs(A0ide))
beta=CF/(CF+CS+Cin)
A0the=A0ide*beta*Adcthe/(1+beta*Adcthe)
A0dBthe=20*log(abs(A0the))
Cout=CL+(1-beta)*CF
wcide=beta*Gmthe/Cout
fcide=wcide/(2*pi)
GBWide=A0ide*fcide
wzide=Gmthe/CF
fzide=wzide/(2*pi)
wcthe=(1+beta*Adcthe)*Gdsthe/Cout
fcthe=wcthe/(2*pi)
GBWthe=A0the*fcthe
wzthe=Gmthe/CF
fzthe=wzthe/(2*pi)

#print(f'Adc = {Adcthe:.3f}')
#print(f'A0ideal = {A0ide:.3f}')
#print(f'beta = {beta:.3f}')
#print(f'A0 = {A0the:.3f}')
#print(f'Cout = {Cout/1e-12:.3f} pF')
#print(f'fc = {fcide/1e3:.3f} kHz (ideal)')
#print(f'fc = {fcthe/1e3:.3f} kHz')
#print(f'fz = {fzide/1e6:.3f} MHz')
#print(f'fz = {fzthe/1e6:.3f} MHz')

Npts=101
logfmin=2
logfmax=8
fmin=pow(10,logfmin)
fmax=pow(10,logfmax)
fthe=np.logspace(logfmin,logfmax,Npts,endpoint=True,base=10.0)

Avide=np.zeros(Npts,dtype=complex)
AvmagdBide=np.zeros(Npts)
Avphidegide=np.zeros(Npts)
Avthe=np.zeros(Npts,dtype=complex)
AvmagdBthe=np.zeros(Npts)
Avphidegthe=np.zeros(Npts)
for k in range(0,Npts):
  jw=1j*2*pi*fthe[k]
  Avide[k]=Av(jw,A0ide,wcide,wzide)
  AvmagdBide[k]=20*log(abs(Avide[k]))
  Avphidegide[k]=np.angle(Avide[k],deg=True)-180
  Avthe[k]=Av(jw,A0the,wcthe,wzthe)
  AvmagdBthe[k]=20*log(abs(Avthe[k]))
  Avphidegthe[k]=np.angle(Avthe[k],deg=True)-180

plt.rcParams.update(BodePlotParams)
fig, axs = plt.subplots(2, sharex=True)

axs[0].semilogx([fmin,fcthe],[A0dBide-3,A0dBide-3],'k--', linewidth=lw)
axs[0].semilogx([fcide,fcide],[-25,A0dBthe-3],'k--', linewidth=lw)
axs[0].semilogx([fmin,GBWthe],[0,0],'k--', linewidth=lw)
axs[0].semilogx([GBWthe,GBWthe],[-25,0],'k--', linewidth=lw)
axs[0].semilogx(fthe,AvmagdBide,'r-',label='Ideal')
axs[0].semilogx(fthe,AvmagdBthe,'r--',label='Incl. finite gain')
axs[0].set(xlim=(fmin,fmax), ylim=(-25,25), ylabel='$|A_v|$ [dB]')
axs[0].set_yticks([-25,-20,-15,-10,-5,0,5,10,15,20,25])
axs[0].legend(loc='best')
textstr1 = '\n'.join((
  f'$|A_0| =$ {A0ide:.0f} ({20*log(A0ide):.0f} dB) (ideal)',
  f'$A_{{dc}} =$ {Adcthe:.0f} ({20*log(Adcthe):.1f} dB)',
  f'$|A_0| =$ {A0the:.1f} ({20*log(A0the):.1f} dB) (effective)',
  f'$f_c =$ {fcide/1e3:.0f} kHz (ideal)',
  f'$f_c =$ {fcthe/1e3:.0f} kHz (effective)',
  f'$GBW =$ {GBWide/1e6:.1f} MHz (ideal)',
  f'$GBW =$ {GBWthe/1e6:.1f} MHz (effective)'))
axs[0].text(1.05, 0.5, textstr1, ha='left', va='center', transform=axs[0].transAxes, size=textFontSize,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
axs[0].text(0.74, 0.95, 'No VS ($\\lambda_c = 0$)', ha='left', va='top', transform=axs[0].transAxes, size=textFontSize,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

axs[1].semilogx([fmin,fcide],[-225,-225],'k--', linewidth=lw)
axs[1].semilogx([fcide,fcide],[-225,-180],'k--', linewidth=lw)
axs[1].semilogx([fmin,GBWthe],[-270,-270],'k--', linewidth=lw)
axs[1].semilogx([GBWthe,GBWthe],[-270,-180],'k--', linewidth=lw)
axs[1].semilogx(fthe,Avphidegide,'b-',label='Ideal')
axs[1].semilogx(fthe,Avphidegthe,'b--',label='Incl. finite gain')
axs[1].set(xlim=(fmin,fmax), ylim=(-360,-180), xlabel='Frequency [Hz]', ylabel='$arg\\{A_v\\}$ [degree]')
axs[1].set_yticks([-360,-315,-270,-225,-180])
axs[1].legend(loc='best')
textstr2 = '\n'.join((
  f'$L =$ {L/1e-6:.0f} $\\mu m$',
  f'$C_L =$ {CL/1e-12:.0f} pF',
  f'$C_S =$ {CS/1e-12:.0f} pF',
  f'$C_F =$ {CF/1e-15:.3f} fF',
  f'$C_{{GD}} =$ {CGD/1e-15:.3f} fF',
  f'$C_{{in}} =$ {Cin/1e-15:.3f} fF',
  f'$\\beta =$ {beta:.3f}',
  f'$IC_{{opt}} =$ {ICopt:.2f}',
  f'$I_{{b,opt}} =$ {Ibopt/1e-9:.0f} nA',
  f'$W_{{opt}} =$ {Wopt/1e-6:.2f} $\\mu m$'))
axs[1].text(1.05, 0.5, textstr2, ha='left', va='center', transform=axs[1].transAxes, size=textFontSize,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.subplots_adjust(hspace=0.1)
plt.show()
plt.style.use(pltStyle)
```


## Simulation results from ngspice
The theoretical results can be validated by comparing them to the results obtained from simulations performed with ngspice. In order to run the simulations you need to have ngspice installed. Please refer to the ngspice instructions.

::: {.callout-note}
The simulations are performed with ngspice @bib:ngspice:2024 using the EKV 2.6 compact model @bib:ekv2p6:doc:rev2:1998. For ngspice, we use the original Verilog-A implementation of EKV 2.6 @bib:grabinski:ekv2p6veriloga:essderc:2019 modified by C. Enz to get the operating point informations and available on the Gitub va-models site provided by D. Warning at @bib:dwarning:2024. The parameters correspond to a generic 180 nm bulk CMOS process @bib:grabinski:ekv2p6_param_extraction:mixdes:2015.
:::

Before running the AC simulation, we first need to check the quiescent voltages and currents and the operating point by running an .OP simulation. The node voltages are extracted from the .ic file and presented in @tbl-op_voltages.

```{python}
#| label: tbl-op_voltages
#| tbl-cap: OTA node voltages with the OTA in open-loop without offset correction.

simtype = ".op"
fileName = circuitName + simtype
simulationPath = "./Simulations/ngspice/"
qucsPath = "./Simulations/qucs-s/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationVoltages = simulationPath + fileName + ".ic"
simulationData = simulationPath + fileName + ".dat"
ngspiceNodeVoltageFile = simulationPath + circuitName + version + simtype + ".ic"
ngspiceDataFile = simulationPath + circuitName + version + simtype + ".dat"

Ib=Ibopt
W1=ekvmos_df.at['M1','W']
L1=ekvmos_df.at['M1','L']
CGD=ekvmos_df.at['M1','CGD']
CGS=ekvmos_df.at['M1','CGS']
CGB=ekvmos_df.at['M1','CGB']
CF0=CF-CGD
Cin=CGS+CGB

if newSim:
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Ib={Ib/1e-9:.0f}n',
    f'.param RF={RF:.3e} CL={CL/1e-12:.3f}p CS={CS/1e-12:.3f}p CF={CF0/1e-15:.3f}f',
    f'.param W1={W1/1e-6:.2f}u L1={L1/1e-6:.2f}u'
  ))
  # Write the transistors sizes and bias to the ngspice directory
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  # Write the transistors sizes and bias to the qucs-s directory
  with open(qucsPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  #print('Starting ngspice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)
  shutil.copy2(simulationData, ngspiceDataFile)

nodeList=["vdd","in","g","out"]
v_df=pd.DataFrame(index=nodeList)
Nnodes=len(nodeList)
for k in range(0,Nnodes):
  nodeName=nodeList[k]
  regexp = re.compile(r'v\(' + nodeName + r'\)' + refloat)
  with open(ngspiceNodeVoltageFile) as f:
    for line in f:
      match = re.search(regexp, line)
      if match:
        v_df.at[nodeName, 'Voltage']=float(match.group(1))

Voutq=v_df.loc['out','Voltage']
#pd.set_option('display.float_format', '{:.2f}'.format)
#v_df

Markdown( 
  tabulate(v_df,
  showindex=True,
  headers=["Node","Voltage"],
  numalign="center",
  stralign="center",
  colalign=("center","center")
))
```

```{python}
#| label: tbl-op1
#| tbl-cap: PSP operating point information extracted from ngspice .op file for each transistor.

ekv2p6mos_df=pd.read_table(ngspiceDataFile, sep=r'\s+', dtype=np.float64, engine='python')
ekv2p6mos_df=ekv2p6mos_df.rename(columns={'@n1[id]': 'Transistor', '@N1[Id]': 'ID', '@N1[Ispec]': 'Ispec', '@N1[IC]': 'IC', '@N1[n0]': 'n', '@N1[Vdsat]': 'VDsat',
                            '@N1[gm]': 'Gm', '@N1[gms]': 'Gms', '@N1[gds]': 'Gds', '@N1[gmbs]': 'Gmb',
                            '@N1[Rn]': 'Rn', '@N1[Vnth]': 'Vnth', '@N1[gamman]': 'gamman', '@N1[Vnfl]': 'Vnfl at 1Hz'})
ekv2p6mos_df['Transistor'] = ekv2p6mos_df['Transistor'].astype(str)

transistor_list=["M1"]
Nmos=len(transistor_list)
for k in range(Nmos):
  ekv2p6mos_df.at[k, 'Transistor'] = transistor_list[k]

ekv2p6mos_df.set_index('Transistor', inplace=True)
ekv2p6mos_df.rename_axis(index=None, inplace=True)
pd.set_option('display.float_format', '{:.2E}'.format)
#ekv2p6mos_df

feature_list=["ID","Ispec","IC","n","VDsat"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(ekv2p6mos_df.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [1,2]:
    table[i][j]=table[i][j]/1e-9
  for j in [5]:
    table[i][j]=table[i][j]/1e-3

Markdown(tabulate(
  table,
  headers=["Transistor","$I_D\\;[nA]$","$I_{spec}\\;[nA]$","$IC$","$n$","$V_{Dsat}\\;[mV]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center"),
  floatfmt=(".3f",".0f",".0f",".3f",".2f",".0f")
))
```

```{python}
#| label: tbl-op2
#| tbl-cap: PSP small-signal operating point information extracted from ngspice .op file for each transistor.

feature_list=["n","Gms","Gm","Gmb","Gds"]

Nfeature=len(feature_list)
table=[]
for mos in transistor_list:
  row=[mos]
  for feature in feature_list:
    row.append(ekv2p6mos_df.at[mos,feature])
  table.append(row)

for i in range(Nmos):
  for j in [2,3,4]:
    table[i][j]=table[i][j]/1e-6
  for j in [5]:
    table[i][j]=table[i][j]/1e-9

Markdown(tabulate(
  table,
  headers=["Transistor","$n$","$G_{ms}\\;[\\mu A/V]$","$G_m\\;[\\mu A/V]$","$G_{mb}\\;[\\mu A/V]$","$G_{ds}\\;[nA/V]$"],
  numalign="center",
  stralign="center",
  colalign=("center","center","center","center","center","center"),
  floatfmt=(".3f",".2f",".3f",".3f",".3f",".3f")
))
```

The large-signal transistor bias information and the small-signal parameters extracted from the simulation are given in @tbl-op1 and @tbl-op2, respectively. We see that their values are very close to the theoretical values given in @tbl-transistor_info1 and @tbl-transistor_info2.

The simulated transfer function is shown in @fig-simulated_tf and compared to the theoretical transfer function of @fig-transfer_function. We see a perfect match between theory and simulation.

```{python}
#| label: fig-simulated_tf
#| fig-cap: "Simulated gain response compared to theoretical estimation."

simtype = ".ac"
fileName = circuitName + simtype
simulationPath = "./Simulations/ngspice/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
ngspiceDataFile = simulationPath + circuitName + version + simtype + ".dat"
ngspiceLogFile = simulationPath + circuitName + version + simtype + ".log"

if newSim:
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We also need to copy the dc simulation log file because it will be overwritten by the next dc simulation
  shutil.copy2(simulationLog, ngspiceLogFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')
fsim=df_sim['frequency'].to_numpy()
AvmagdBsim=df_sim['AmagdB'].to_numpy()
Avphidegsim=df_sim['Aphdeg'].to_numpy()
Npts=len(fsim)
fmin=fsim[0]
fmax=fsim[Npts-1]

for k in range(0,Npts):
  if Avphidegsim[k]>0:
    Avphidegsim[k]=Avphidegsim[k]-360
  else:
    Avphidegsim[k]=Avphidegsim[k]

regexp = re.compile(r'adc' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      AdcdBsim=float(match.group(1))

regexp = re.compile(r'gbw' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      GBWsim=float(match.group(1))

regexp = re.compile(r'pgbw' + refloat)
with open(ngspiceLogFile) as f:
  for line in f:
    match = re.match(regexp, line)
    if match:
      PGBWsim=float(match.group(1))


Gmsim=ekv2p6mos_df.at['M1','Gm']
Gdssim=ekv2p6mos_df.at['M1','Gds']
Adcsim=Gmsim/Gdssim
A0dBsim=AvmagdBsim[0]
A0sim=pow(10,A0dBsim/20)
A0dBthe=20*log(abs(A0the))

plt.rcParams.update(BodePlotParams)
fig, axs = plt.subplots(2, sharex=True)

#axs[0].semilogx([fmin,GBWsim],[0,0],'k--', linewidth=lw)
#axs[0].semilogx([GBWsim,GBWsim],[0,-60],'k--', linewidth=lw)
axs[0].semilogx(fsim,AvmagdBsim,'ro', markersize=4, markevery=15, label='Simulation')
axs[0].semilogx(fthe,AvmagdBthe,'r-',label='Theory')
axs[0].set(xlim=(fmin,fmax), ylim=(-25,25), ylabel='$|A_{vd}|$ [dB]')
axs[0].set_yticks([-25,-20,-15,-10,-5,0,5,10,15,20,25])
axs[0].legend(loc='lower left')
textstr1 = '\n'.join((
  f'$A_{{dc}} =$ {Adcthe:.1f} (theory)',
  f'$A_{{dc}} =$ {Adcsim:.1f} (sim)',
  f'$|A_0| =$ {A0dBthe:.1f} dB (theory)',
  f'$|A_0| =$ {A0dBsim:.1f} dB (sim.)',
  f'$GBW =$ {GBWthe/1e6:.1f} MHz (theory)',
  f'$GBW =$ {GBWsim/1e6:.1f} MHz (sim.)'))
axs[0].text(1.05, 0.5, textstr1, ha='left', va='center', transform=axs[0].transAxes, size=textFontSize,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})

#axs[1].semilogx([fmin,GBWsim],[PGBWsim,PGBWsim],'k--', linewidth=lw)
#axs[1].semilogx([GBWsim,GBWsim],[PGBWsim,0],'k--', linewidth=lw)
axs[1].semilogx(fsim,Avphidegsim,'bo', markersize=4, markevery=15, label='Simulation')
axs[1].semilogx(fthe,Avphidegthe,'b-',label='Theory')
axs[1].set(xlim=(fmin,fmax), ylim=(-360,-180), xlabel='Frequency [Hz]', ylabel='$arg\\{A_{vd}\\}$ [degree]')
#axs[1].set_xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
axs[1].set_yticks([-360,-315,-270,-225,-180])
axs[1].legend(loc='lower left')
textstr2 = '\n'.join((
  f'$L =$ {L/1e-6:.0f} $\\mu m$',
  f'$C_L =$ {CL/1e-12:.0f} pF',
  f'$C_S =$ {CS/1e-12:.0f} pF',
  f'$C_F =$ {CF/1e-15:.0f} fF',
  f'$C_{{F0}} =$ {CF0/1e-15:.3f} fF',
  f'$C_{{GD}} =$ {CGD/1e-15:.3f} fF',
  f'$C_{{in}} =$ {Cin/1e-15:.3f} fF',
  f'$\\beta =$ {beta:.3f}',
  f'$IC_{{opt}} =$ {ICopt:.2f}',
  f'$I_{{b,opt}} =$ {Ibopt/1e-9:.0f} nA',
  f'$W_{{opt}} =$ {Wopt/1e-6:.2f} $\\mu m$'))
axs[1].text(1.05, 0.5, textstr2, ha='left', va='center', transform=axs[1].transAxes, size=textFontSize,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.subplots_adjust(hspace=0.1)
plt.show()
plt.style.use(pltStyle)
```

::: {.callout-tip title="Question"}
Is this truly the minimum current?
:::

We can check this by sweeping $IC$ and running a simulation for each of these point keeping the same specifications as in @tbl-specs. This leads to the family of transfer functions shown in @fig-tf_sweep_ic. We see that all the simulations match the specification for different bias currents. The actual bias currents are plotted versus the inversion coefficient in @fig-ib_sweep_ic. We see that the bias current is indeed minimum at the theoretical value extracted above.

::: {.callout-note}
We observe that the minimum is rather flat and therefore not too sensitive to the value of the optimum inversion coefficient.
:::

```{python}
#| label: fig-tf_sweep_ic
#| fig-cap: Simulated gain response for various values of the inversion coefficient $IC$.

simtype = ".ac"
fileName = circuitName + simtype
simulationPath = "./Simulations/ngspice/sweep/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"

# Specs
GBW=1e6
A0dB=20
CL=1e-12
CF=100e-15
L=1e-6

# Parameters that do not depand on IC nor on W/L (they depend on L though)
nUT=n0n*UT
A0=pow(10,A0dB/20)
CS=A0*CF
fc=GBW/A0
wc=2*pi*fc
wL=Ispecsqn/((1+CS/CL+CS/CF)*CL*nUT)
wW=Ispecsqn/((1+CL/CF)*CGW*L*nUT)
Omega=wc/wL
theta=wc/wW
ICopt=ICopt_theta(theta)
ibopt=ibopt_theta(theta)
ARopt=ARopt_theta(theta)
Ibopt=ibopt*Ispecsqn*Omega
fl=10
wl=2*pi*fl
RF=A0/(wl*CS)

logICmin=-2
logICmax=1
ICmin=pow(10,logICmin)
ICmax=pow(10,logICmax)
NptsDec=6
Ncurves=(abs(logICmin)+abs(logICmax))*NptsDec+1
IC=np.logspace(logICmin,logICmax,Ncurves,endpoint=True,base=10.0)
#IC=5*IC
colors=plt.cm.rainbow(np.linspace(0, 1, Ncurves))

Ib=np.zeros(Ncurves)

plt.rcParams.update(BodePlotParams)
fig, axs = plt.subplots(2, sharex=True)

for m in range(0,Ncurves):
  ib=IC[m]/(gms_ic(IC[m])-theta)
  Ib[m]=Ispecsqn*Omega*ib
  AR=1/(gms_ic(IC[m])-theta)
  WoverL=Omega*AR
  W=WoverL*L
  CGD=W*CGDOn
  CF0=CF-CGD
  paramstr = '\n'.join((
    f'.param VDD={VDD:.1f} Ib={Ib[m]/1e-9:.0f}n',
    f'.param RF={RF:.3e} CL={CL/1e-12:.3f}p CS={CS/1e-12:.3f}p CF={CF0/1e-15:.3f}f',
    f'.param W1={W/1e-6:.2f}u L1={L/1e-6:.2f}u'
  ))
  #print(paramstr)
  with open(simulationPath+'size_bias.par', 'w') as f:
    f.write(paramstr)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting dc simulation data file because it will be overwritten by the next dc simulation
  df_sim=pd.read_table(simulationData, sep=' +', engine='python')
  fsim=df_sim['frequency'].to_numpy()
  AvmagdBsim=df_sim['AmagdB'].to_numpy()
  Avphidegsim=df_sim['Aphdeg'].to_numpy()
  for k in range(0,Npts):
    if Avphidegsim[k]>0:
      Avphidegsim[k]=Avphidegsim[k]-360
    else:
      Avphidegsim[k]=Avphidegsim[k]
  Npts=len(fsim)
  fmin=fsim[0]
  fmax=fsim[Npts-1]
  axs[0].semilogx(fsim, AvmagdBsim, color=colors[m], label='$IC =$' + f'{IC[m]:.3f}')
  axs[1].semilogx(fsim, Avphidegsim, color=colors[m], label='$IC =$' + f'{IC[m]:.3f}')

axs[0].semilogx([fmin,GBW],[0,0],'k--', linewidth=lw)
axs[0].semilogx([GBW,GBW],[-25,0],'k--', linewidth=lw)
axs[0].semilogx([fmin,fc],[17,17],'k--', linewidth=lw)
axs[0].semilogx([fc,fc],[-25,17],'k--', linewidth=lw)
axs[0].set(xlim=(fmin,fmax), ylim=(-25,25), ylabel='$|A_{vd}|$ [dB]')
axs[0].set_yticks([-25,-20,-15,-10,-5,0,5,10,15,20,25])
#axs[0].legend(loc='lower left')
axs[0].legend(loc='upper left', bbox_to_anchor=(1, 1))

axs[1].semilogx([fc,fc],[-360,-180],'k--', linewidth=lw)
axs[1].semilogx([fmin,fc],[-225,-225],'k--', linewidth=lw)
axs[1].semilogx([GBW,GBW],[-360,-180],'k--', linewidth=lw)
axs[1].semilogx([fmin,GBW],[-270,-270],'k--', linewidth=lw)
axs[1].set(xlim=(fmin,fmax), ylim=(-360,-180), xlabel='Frequency [Hz]', ylabel='$arg\\{A_{vd}\\}$ [degree]')
#axs[1].set_xticks([1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8])
axs[1].set_yticks([-360,-315,-270,-225,-180])
#axs[1].legend(loc='lower left')
textstr = '\n'.join((
    f'$|A_0| =$ {A0dB:.0f} dB',
    f'$GBW =$ {GBW/1e6:.0f} MHz',
    f'$f_c =$ {fc/1e3:.0f} kHz',
    f'$C_L =$ {CL/1e-12:.0f} pF',
    f'$C_F=$ {CF/1e-12:.1f} pF',))
axs[1].text(0.05, 0.06, textstr, ha='left', va='bottom', transform=axs[1].transAxes, size=textFontSize,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.subplots_adjust(hspace=0.1)
plt.show()
plt.style.use(pltStyle)
```

```{python}
#| label: fig-ib_sweep_ic
#| fig-cap: Bias current $I_b$ versus inversion coefficient $IC$ corresponding to the transfer functions shown in @fig-tf_sweep_ic.

plt.semilogx([ICopt,ICopt], [0,Ibopt/1e-9], 'k--', linewidth=lw)
plt.semilogx([ICmin,ICopt], [Ibopt/1e-9,Ibopt/1e-9], 'k--', linewidth=lw)
plt.semilogx(IC, Ib/1e-9, 'o-', color=colors[m], label='Simulation')
plt.semilogx([ICopt,ICopt], [Ibopt/1e-9,Ibopt/1e-9], 'ob', label='Minimum')
plt.xlim(ICmin,ICmax)
#plt.xticks(np.arange(0,11,1))
plt.xlabel('$IC$')
plt.ylim(0,1e3)
#plt.yticks(np.arange(0,1.1,0.1))
plt.ylabel('Bias current $I_b$ [nA]')
#plt.legend(loc='lower right')
textstr = '\n'.join((
    f'$|A_0| =$ {A0dB:.0f} dB',
    f'$GBW =$ {GBW/1e6:.0f} MHz',
    f'$f_c =$ {fc/1e3:.0f} kHz',
    f'$C_L =$ {CL/1e-12:.0f} pF',
    f'$C_F=$ {CF/1e-12:.1f} pF',))
plt.text(0.05, 0.95, textstr, ha='left', va='top', size=textFontSize, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.annotate('$IC_{{opt}} =$' + f'{ICopt:.3f}', size=textFontSize,
             xy=(ICopt, 0), xycoords='data',
             xytext=(0, -20), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='center', va='top')
plt.annotate('$I_{{b,opt}} =$' + f'{Ibopt/1e-9:.0f}', size=textFontSize,
             xy=(1e-2, Ibopt/1e-9), xycoords='data',
             xytext=(-25, -25), textcoords='offset points',
             bbox=dict(boxstyle='square,pad=0', fc='w', ec='none'),
             arrowprops=dict(arrowstyle="-|>", shrinkA=0, capstyle='butt', ec='k', fc='k', joinstyle='miter'),
             ha='right', va='top')
plt.show()
```

# Conclusion
In this notebook we have optimized a single transistor SC amplifier for minimum power consumption. We started to analyze the circuit accounting for the input parasitic capacitance which scales with the width of the transistor. We have found that there is an optimum transistor inversion coefficient and  width for achieving a certain bandwidth with a minimum bias current. We then illustrated the theory with an example. The sized circuit was then simulated with ngspice using the EKV 2.6 compact model for a generic 180nm CMOS technology. The simulation results perfectly match the theory.

::: {.callout-note}
Note that the above optimization can be applied to many switched-capacitor amplifers using an OTA as the amplifier with a feedback capacitor. 
:::

# References
