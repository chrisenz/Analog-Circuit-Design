---
title: "OTA with Capacitive Feedback"
subtitle: "Step Response (Version 1)"
author: "Christian Enz"
affiliation: "EPFL"
date: today
execute:
  echo: false
  warning: false
toc: true
number-sections: true
number-depth: 3
highlight-style: pygments
bibliography: references.bib
csl: ieee.csl
format: 
  html:
    include-in-header: mathjax.html
    code-fold: true
    html-math-method: mathjax
    css: styles.css
  pdf:
    keep-tex: true
    link-citations: true
    pdf-engine: pdflatex
    documentclass: scrreprt
    papersize: a4
    geometry: 
      - top=20mm
      - bottom=20mm
      - left=20mm
      - right=20mm
---

```{python}
#| init_cell: true

from ekv_functions import *

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import subprocess
import shutil
import os
import os.path as op
import sys
sys.path.append(".")
import re

from scipy import constants as cons
from IPython.display import Markdown
from tabulate import tabulate
from matplotlib.ticker import EngFormatter
from matplotlib.ticker import LogFormatterMathtext
from IPython.display import display, Latex
from numpy import sinh as sinh

inkscapePath = r"C:\Program Files\Inkscape\bin\inkscape.exe"
savePlotPath = "./Plots/"
#savePlot=True
savePlot=False

#plt.rcParams['text.usetex'] = True
plt.rcParams['svg.fonttype'] = 'none'
plt.rcParams['pdf.fonttype'] = 42
#plt.rcParams['ps.fonttype'] = 42
plt.rcParams['font.family'] = 'Arial'
#plt.rcParams['mathtext.fontset'] = 'cm'

plt.rcParams['mathtext.fontset'] = 'custom'
plt.rcParams['mathtext.rm'] = 'Arial'
plt.rcParams['mathtext.it'] = 'Arial:italic'
plt.rcParams['mathtext.bf'] = 'Arial:bold'

#plt.rcParams['text.usetex'] = True
plt.rcParams['svg.fonttype'] = 'none'
plt.rcParams['pdf.fonttype'] = 42
#plt.rcParams['ps.fonttype'] = 42
plt.rcParams['font.family'] = 'Arial'
#plt.rcParams['mathtext.fontset'] = 'cm'

plt.rcParams['mathtext.fontset'] = 'custom'
plt.rcParams['mathtext.rm'] = 'Arial'
plt.rcParams['mathtext.it'] = 'Arial:italic'
plt.rcParams['mathtext.bf'] = 'Arial:bold'

#plt.style.use('plt_style.mplstyle')
#plt.style.use('plt_style_small.mplstyle')
plt.style.use('plt_style_medium.mplstyle')

lw=1
msize=5

def saveFigures(savePath, plotName):
  print("\nPatience, saving plot!")
  figFolder = savePath + r"\\{}.{}"
  pngFile = figFolder.format(plotName,"png")
  pdfFile = figFolder.format(plotName,"pdf")
  svgFile = figFolder.format(plotName,"svg")
  plt.savefig(pngFile, format="png", dpi=1200, bbox_inches="tight", transparent=True)
  plt.savefig(pdfFile, format="pdf", dpi=1200, bbox_inches="tight", transparent=True)
  plt.savefig(svgFile, format="svg", dpi=1200, bbox_inches="tight", transparent=True)
  cmd_emf = '"{}" "{}\\{}.svg" --export-filename="{}\\{}.emf" --export-overwrite'.format(inkscapePath, savePath, plotName, savePath, plotName)
#    cmd_emf = '"{}" "{}\{}.pdf" --export-filename="{}\{}.emf" --export-overwrite'.format(inkscapePath, savePath, plotName, savePath, plotName)
#    cmd_pdf = '"{}" "{}\{}.svg" --export-filename="{}\{}.pdf" --export-overwrite'.format(inkscapePath, savePath, plotName, savePath, plotName)
  subprocess.call(cmd_emf, shell=True)
#    subprocess.call(cmd_pdf, shell=True)

circuitName="OTA_with_cap_feedback"
version = "_v1" # Allows you to save different versions
#newSim=True # Resimulate the circuit
newSim=False # Use the data generated by the previous simulatgion without performing a new simulation (faster)
refloat=r'.*?([+-]?\d+([.]\d*)?([eE][+-]?\d+)?|[.]\d+([eE][+-]?\d+)?)'
```

# Introduction

![Schematic of an OTA with capacitive feedback.](Figures/OTA_with_capacitive_feedback.png){#fig-OTA_with_capacitive_feedback}

The design of OTAs used in SC circuits requires a good estimation of the required settling time to make sure that the charge transfer is complete. In this notebook we start with a linear analysis of the amplifier for deriving the small-signal settling time. However, the OTA show a very nonlinear behavior, particularly when it is biased in weak inversion. As soon as its differential input voltage gets larger than a few $U_T$, the output current saturates and the output voltage is then slewing before recovering the linear settling. This slewing period obviously increases the settling time and can even become dominant for low-power OTA where the bias current of the input differential pair is very small. We therefore will conduct a nonlinear analysis to derive an expression of the settling time that includes this period of slewing @bib:krummenacher:leg:1982.

# Small-signal Analysis
## Transfer Function

![Small-signal schematic assuming a single-stage OTA.](Figures/Small_signal_schematic.png){#fig-Small_signal_schematic}

The equivalent linear schematic of @fig-OTA_with_capacitive_feedback is shown in @fig-Small_signal_schematic where we have assumed that the OTA is a single-stage OTA and can be replaced by a simple VCCS of value $G_m$ with an output resistance $R_{out}$. From @fig-Small_signal_schematic, it is easy to show that the voltage transfer function is given by
\begin{equation}
  A(s) \triangleq \frac{\Delta V_{out}}{\Delta V_{in}} = A_0 \cdot \frac{1-s/\omega_z}{1+s/\omega_p}
\end{equation}
where $A_0$ is the amplifier DC gain, $\omega_p$ the cut-off frequency and $\omega_z$ the zero given by
\begin{align}
  A_0 &= A_{0,ideal} \cdot \frac{\beta\,A_{dc}}{1 + \beta\,A_{dc}},\\
  A_{0,ideal} &= -\frac{C_S}{C_F},\\
  \omega_p &= \frac{1+\beta\,A_{dc}}{R_{out}\,C_{out}},\\
  \omega_z &= \frac{G_m}{C_F}.
\end{align}
$A_{dc} = G_m \cdot R_{out}$ is the OTA DC voltage gain, $\beta\,A_{dc}$ the DC loop gain, $\beta$ the feedback gain and $C_{out}$ the total capacitance seen at the output. If the loop-gain $\beta\,A_{dc} \gg 1$, the amplifier DC gain and cut-off frequency simplify to
\begin{align}
  A_0 &\cong A_{0,ideal} = -\frac{C_S}{C_F},\\
  \omega_p &\cong \frac{\beta\,A_{dc}}{R_{out}\,C_{out}} = \frac{\beta\,G_m}{C_{out}}.
\end{align}

![Equivalent circuit to evaluate the feedback gain $\beta$.](Figures/Feedback_gain.png){#fig-feedback_gain}

The feedback gain $\beta$ can be calculated from the schematic shown in @fig-feedback_gain as
\begin{equation}
  \beta \triangleq \frac{V}{V_{out}} = \frac{C_F}{C_F + C_S + C_{in}}.
\end{equation}

The amplifier bandwidth is given by $\omega_c = \omega_p \cong \beta \cdot G_m/C_{out}$ where the total capacitance seen at the output $C_{out}$ can be expressed as
\begin{equation}
  C_{out} = C_L + \frac{C_S + C_{in}}{C_F + C_S + C_{in}} \cdot C_F,
\end{equation}
which can also be written in terms of the feedback factor $\beta$ as
\begin{equation}
  C_{out} = C_L + \beta \cdot (C_S + C_{in}) = C_L + (1-\beta) \cdot C_F.
\end{equation}

![Small-signal transfer function of the amplifier.](Figures/Transfer_function.png){#fig-transfer_function}

In order to achieve some DC gain, $C_F$ is smaller than $C_S$ and usually also smaller than $C_L$. This means that the right-hand side (RHS) zero is located higher than the unity gain frequency which is then simply given by $\omega_u \cong G_m/C_{out}$. For frequencies below $\omega_u$, the magnitude of the transfer function is shown in @fig-transfer_function.

We now will derive the small-signal step response.

## Step response
The small-signal step response for an input step voltage $\Delta V_{in}$ is obtained by taking the inverse Laplace transform of
\begin{equation}
  V_{out}(s)= \frac{\Delta V_{in}}{s} \cdot A(s),
\end{equation}
resulting in
\begin{equation}\label{eqn:vout_small}
  V_{out}(t) = u(t) \cdot \Delta V_{in} \cdot A_0 \cdot \left[1 - \left(1+\frac{\tau_z}{\tau_p}\right) \cdot e^{-\frac{t}{\tau_p}}\right].
\end{equation}
where $\tau_z \triangleq 1/\omega_z$ and $\tau_p \triangleq 1/\omega_p$ and $u(t)$ is the unit step
\begin{equation}
  u(t) =
  \begin{cases}
    1 & \textsf{for $0 < t$}\\
    0 & \textsf{elsewhere}.
  \end{cases}
\end{equation}

The $\tau_z/\tau_p$ ratio is approximately given by
\begin{equation}
  \frac{\tau_z}{\tau_p} \cong \beta \cdot \frac{C_F}{C_{out}}.
\end{equation}

The steady-state value $V_{out}(t \rightarrow \infty)$ is given by
\begin{equation}
  V_{out\infty} \triangleq V_{out}(t \rightarrow \infty) = \Delta V_{in} \cdot A_0 = A_{0,ideal} \cdot \frac{\beta\,A_{dc}}{1+\beta\,A_{dc}} \cdot \Delta V_{in} = \frac{A_{0,ideal}}{1+\frac{1}{\beta\,A_{dc}}} \cdot \Delta V_{in},
\end{equation}
which for $\beta\,A_{dc} \gg 1$ simplifies to
\begin{equation}
  V_{out\infty} \cong A_{0,ideal} \cdot (1-\varepsilon_{gain}) \cdot \Delta V_{in} \cong A_{0,ideal} \cdot \Delta V_{in},
\end{equation}
where $\varepsilon_{gain} =1/(\beta\,A_{dc}) \ll 1$ is the relative settling error due to the OTA finite DC gain.

![Capacitive network at $t=0$.](Figures/Capacitive_network.png){#fig-Capacitive_network}

The positive zero introduces a step at $t=0$ that is opposite to the final value
\begin{align}
  V_{out}(t=0^+) &= -V_{out\infty} \cdot \frac{\tau_z}{\tau_p} = -\Delta V_{in} \cdot A_0 \cdot \frac{\tau_z}{\tau_p} \cong -\Delta V_{in} \cdot A_{0,ideal} \cdot \beta \cdot \frac{C_F}{C_{out}}\\
  &= \Delta V_{in} \cdot \frac{C_S\,C_F}{(C_S+C_{in})\,(C_F+C_L)+C_F\,C_L},\label{eqn:DVout0}
\end{align}
This comes from the fact that at time $t=0^+$, the OTA did not yet react and the voltage step $\Delta V_{in}$ imposed at the input is transmitted directly to the output through the capacitive network shown in @fig-Capacitive_network, resulting in
\begin{align}
  V_{out}(t=0^+) &= \Delta V_{in} \cdot \frac{C_S}{C_S+C_{in}+\frac{C_F\,C_L}{C_F+C_L}} \cdot \frac{C_F}{C_F+C_L}\\
  &= \Delta V_{in} \cdot \frac{C_S\,C_F}{(C_S+C_{in})\,(C_F+C_L)+C_F\,C_L}
\end{align}
which is identical to \eqref{eqn:DVout0}. The step response starts in the wrong direction and then settles to the steady-state value as illustrated in @fig-Step_response.

![Small-signal step response.](Figures/Step_response.png){#fig-Step_response}

## Settling Time
As shown in @fig-Step_response, the small-signal settling time $t_{set}$ is defined as the time required for the output voltage to approach the steady-state value with a precision equal to $\varepsilon_{set}$
\begin{equation}
  V_{out}(t=t_{set}) = (1-\varepsilon_{set}) \cdot V_{out}(t \rightarrow \infty)
\end{equation}
which leads to
\begin{equation}\label{eqn:tset_linear}
  t_{set} = -\tau_p \cdot \ln\left(\frac{\varepsilon_{set}}{1+\tau_z/\tau_p}\right)
  = -\tau_p \cdot \ln\left(\frac{\varepsilon_{set}}{1+\beta\,C_F/C_{out}}\right)
  \cong -\tau_p \cdot \ln\left[\varepsilon_{set} \cdot \left(1 - \beta \cdot \frac{C_F}{C_{out}}\right)\right].
\end{equation}

## Example
```{python}
UT=25.6e-3
n=1.3
nUT=n*UT
fck=1e6
Ts=1/fck
tset=Ts/2
eset=1e-3
A0ideal=-1
Adc=1000
Cin=10e-15
CF=1e-12
CS=CF*abs(A0ideal)
CL=0.1e-12
beta=CF/(CF+CS+Cin)
A0=A0ideal/(1+1/(beta*Adc))
Cout=CL+(1-beta)*CF
DVin=-10e-3
taup=tset/-ln(eset*(1-beta*Cout/CF))
#taup=-tset/ln(eset)
wp=1/taup
fp=wp/(2*pi)
wu=wp/beta
fu=wu/(2*pi)
Gm=wu*Cout
Rout=Adc/Gm
tauz=CF/Gm
wz=1/tauz
fz=wz/(2*pi)
Voutinf=A0*DVin
Vout0=-Voutinf*tauz/taup
```

![Non-overlaping phases for the SC amplifier shown in @fig-SC_amplifier_phase1 and @fig-SC_amplifier_phase2.](Figures/SC_amplifier_phases.png){#fig-SC_amplifier_phases}

![SC amplifier with offset cancellation during the reset or autozero phase (phase $\Phi_1$).](Figures/SC_amplifier_phase1.png){#fig-SC_amplifier_phase1}

![SC amplifier with offset cancellation during the amplification phase (phase $\Phi_2$).](Figures/SC_amplifier_phase2.png){#fig-SC_amplifier_phase2}

The circuit shown in @fig-SC_amplifier_phase1 and @fig-SC_amplifier_phase2 is a SC amplifier with autozero offset cancelation. It uses the two non-.overlapping phases shown in @fig-SC_amplifier_phases. During phase $\Phi_1$, the sampling and feedback capacitances $C_S$ and $C_F$ are reset and sample the OTA offset voltage. During phase $\Phi_2$ the input voltage is amplified with ideally a gain equal to $A_{0,ideal} = -C_S/C_F$. It is easy to show that the offset voltage is canceled.

We want to design this SC amplifer for an ideal unity gain $A_{0,ideal} =$ `{python} f'{A0ideal:.0f}'` and operating with a clock frequency $f_{ck} =$ `{python} f'{fck/1e6:.0f}'` $MHz$. We want the signal to settle within a half clock period for an input step voltage $\Delta V_{in} =$ `{python} f'{DVin/1e-3:.0f}'` $mV$ with a precision $\varepsilon_{set} =$ `{python} f'{eset:.0e}'`. The settling time is therefore $t_{set} =$ `{python} f'{tset/1e-9:.0f}'` $ns$. Assuming the feedback, load and input capacitances are given by $C_F =$ `{python} f'{CF/1e-12:.1f}'` $pF$, $C_L =$ `{python} f'{CL/1e-12:.1f}'` $pF$ and $C_{in} =$ `{python} f'{Cin/1e-15:.0f}'` $fF$, we need to find the required transconductance of the OTA. The specifications are summarized in @tbl-example_small_step_specs and the calculated parameters are given in @tbl-example_small_step.

```{python}
#| label: tbl-example_small_step_specs
#| tbl-cap: Specifications for the small-signal step response.

table = [["Clock frequency","$f_{{ck}}$",f'{fck/1e6:.0f}',"$MHz$"],
         ["Clock period","$T_s$",f'{Ts/1e-6:.0f}',"$\\mu s$"],
         ["Settling time","$t_{{set}}$",f'{tset/1e-9:.0f}',"$ns$"],
         ["Settling error","$\\varepsilon_{{set}}$",f'{eset:.1e}',"-"],
         ["Ideal DC gain","$A_{{0,ideal}}$",f'{A0ideal:.0f}',"-"],
         ["OTA DC gain","$A_{{dc}}$",f'{Adc:.0e}',"-"],
         ["Feedback capacitance","$C_F$",f'{CF/1e-12:.0f}',"$pF$"],
         ["Load capacitance","$C_L$",f'{CL/1e-12:.1f}',"$pF$"],
         ["Input capacitance","$C_{{in}}$",f'{Cin/1e-15:.0f}',"$fF$"],
         ["Input step","$\\Delta V_{{in}}$",f'{DVin/1e-3:.0f}',"$mV$"]
         ]

Markdown(tabulate(
  table,
  headers=["Parameter","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center")
))
```

```{python}
#| label: tbl-example_small_step
#| tbl-cap: Calculated parameters for the small-signal step response.

table = [["Source capacitance","$C_S$",f'{CS/1e-12:.0f}',"$pF$"],

         ["Feedback gain","$\\beta$",f'{beta:.3f}',"-"],
         ["Effective DC gain","$A_0$",f'{A0:.3f}',"-"],
         ["Total output capacitance","$C_{{out}}$",f'{Cout/1e-12:.3f}',"$pF$"],
         ["Time constant","$\\tau_p$",f'{taup/1e-9:.3f}',"$ns$"],
         ["Time constant","$\\tau_z$",f'{tauz/1e-9:.3f}',"$ns$"],
         ["Pole","$f_p$",f'{fp/1e6:.3f}',"$MHz$"],
         ["Zero","$f_z$",f'{fz/1e6:.3f}',"$MHz$"],
         ["Initial output voltage","$V_{{out}}(t=0^+)$",f'{Vout0/1e-3:.3f}',"$mV$"],
         ["Final output voltage","$V_{{out}}(t \\rightarrow \\infty)$",f'{Voutinf/1e-3:.3f}',"$mV$"],
         ["Gain-bandwidth product","$f_u$",f'{fu/1e6:.3f}',"$MHz$"],
         ["OTA Transconductance","$G_m$",f'{Gm/1e-6:.3f}',"$\\mu A/V$"],
         ["OTA output resistance","$R_{{out}}$",f'{Rout/1e6:.3f}',"$M \\Omega$"]
         ]

Markdown(tabulate(
  table,
  headers=["Parameter","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center")
))
```

This example can be simulated using ngspice with the model of the OTA given in @sec-example_large_signal. For small-signal operation (i.e. for a differential input voltage $V_{id} \ll 2nU_T$), this nonlinear model reduces to a linear OTA with a transconductance equal to $G_m$. The simulation results are presented in @fig-ng_small_step and compared to the theoretical estimation. We see a perfect agreement between the theoretical model and the simulation.

```{python}
#| label: fig-ng_small_step
#| fig-cap: "Step response of the OTA operating as a voltage inverter for a small input step."

simtype = ".tran"
fileName = circuitName + simtype
simulationPath = "./Simulations/ngspice/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
simulationVoltages = simulationPath + fileName + ".ic"
ngspiceDataFile = simulationPath + circuitName + version + simtype + "1.dat"
ngspiceNodeVoltageFile = simulationPath + circuitName + version + simtype + "1.ic"

Visat=2*n*UT
V1=0
V2=DVin
td=0.1e-6
tr=10e-12
tf=10e-12
pw=1
per=1
nper=0

if newSim:
  paramstr = '\n'.join((
  f'.param Gm={Gm/1e-6:.3f}u Rout={Rout/1e6:.3f}MEG Visat={Visat/1e-3:.1f}m',
  f'.param CL={CL/1e-15:.0f}f CF={CF/1e-15:.0f}f CS={CS/1e-12:.0f}p Cin={Cin/1e-15:.0f}f'
  ))
  with open(simulationPath+'parameters.par', 'w') as f:
    f.write(paramstr)
  pulsestr = f'.param V1={V1:.3f} V2={V2:.3f} td={td:.3e} tr={tr:.3e} tf={tf:.3e} pw={pw:.3e} per={per:.3e} np={nper:.0f}'
  with open(simulationPath+'pulse.par', 'w') as f:
    f.write(pulsestr)
  Nsteps=1000
  tstart=0
  tstop=0.6e-6
  tstep=(tstop-tstart)/Nsteps
  simpar = '\n'.join((
    f'.csparam tstep={tstep:.3e}',
    f'.csparam tstop={tstop:.3e}',
    f'.csparam tstart={tstart:.0f}'
    ))
  simparFile = simulationPath + "simulation.tran.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting tran simulation data file because it will be overwritten by the next tran simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

tsim=df_sim['time'].to_numpy()
Vinsim=df_sim['v(in)'].to_numpy()
Voutsim=df_sim['v(out)'].to_numpy()

Npts=len(tsim)
tmin=tsim[0]
tmax=tsim[Npts-1]

Voutthe=np.zeros(Npts)

for k in range(0,Npts):
  if tsim[k]<td:
    Voutthe[k]
  else:
    Voutthe[k]=DVin*A0*(1-(1+tauz/taup)*exp(-(tsim[k]-td)/taup))

#plt.plot([td/1e-6,(td+1/(2*pi*GBWthe))/1e-6],[0,DVin/1e-3], 'k--', linewidth=lw)
#plt.plot([0,tmax/1e-6],[Voutfin/1e-3,Voutfin/1e-3], 'k--', linewidth=lw)
plt.plot(tsim/1e-6,Vinsim/1e-3,'b-', label='Input step')
plt.plot(tsim/1e-6,-Vinsim/1e-3,'b--')
plt.plot(tsim/1e-6,Voutthe/1e-3,'r-', label='Output (Theory)')
plt.plot(tsim/1e-6,Voutsim/1e-3,'ro', label='Output (Sim.)', markevery=20, markersize=4)
plt.xlim(tmin/1e-6,tmax/1e-6)
#plt.xticks(np.arange(0,1.2,0.1))
plt.xlabel('Time [$\\mu s$]')
#plt.ylim(0,350)
plt.ylabel('$\\Delta V_{in}$, $\\Delta V_{out}$ [mV]')
plt.legend(loc='best')
#plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
textstr = '\n'.join((
  f'$\\Delta V_{{in}} =$ {DVin/1e-3:.0f} mV',
  f'$C_S =$ {CS/1e-12:.0f} $pF$',
  f'$C_F =$ {CF/1e-12:.0f} $pF$',
  f'$C_L =$ {CL/1e-15:.0f} $fF$',
  f'$C_{{in}} =$ {Cin/1e-15:.0f} $fF$',
  f'$C_{{out}} =$ {Cout/1e-15:.0f} $fF$',
  f'$\\beta =$ {beta:.3f}',
  f'$A_{{0,ideal}} =$ {A0ideal:.0f}',
  f'$A_{{dc}} =$ {Adc:.0f}',
  f'$G_m =$ {Gm/1e-6:.1f} $\\mu A/V$',
  f'$\\tau_p =$ {taup/1e-9:.3f} $ns$',
  f'$\\tau_z =$ {tauz/1e-9:.3f} $ns$',
  f'$V_{{out}}(0) =$ {Vout0/1e-3:.3f} $mV$',
  f'$V_{{out}}(t \\rightarrow \\infty) =$ {Voutinf/1e-3:.3f} $mV$'))
plt.text(1.05, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

In the next section we will derive the large-signal step response accounting for the OTA nonlinear behavior coming from the input differential pair.

# Large-signal Analysis

::: {.callout-note}
This section has been largely inspired from the work of F. Krummenacher in @bib:krummenacher:leg:1982.
:::

In the capacitively coupled amplifier shown in @fig-OTA_with_capacitive_feedback, at $t=0^+$ the virtual ground may see a voltage that is large enough for the input differential pair to saturate. In this situation and assuming a single-stage OTA, the current delivered by the OTA is limited by the differential pair bias current $2 I_b$ and the output voltage is slewing linearly until the OTA input voltage comes back to the linear region. This phenomenon is described by the slew-rate $SR$, which is defined as the maximum change rate of the output voltage
\begin{equation}
  SR = \frac{dV_{out}}{dt} = \frac{2 I_b}{C_{out}}.
\end{equation}

This slewing might significantly increase the settling time compared to the value obtained from the linear analysis and given in \eqref{eqn:tset_linear}. In the following section we will make a large-signal analysis and derive an expression of the settling time that includes the effect of slewing.

## Step Response {#sec-nonlinear_step_response}

![Schematic for large-signal analysis.](Figures/Nonlinear_analysis.png){#fig-Nonlinear_analysis}

To perform a large-signal analysis we can reuse the schematic of @fig-OTA_with_capacitive_feedback where the linear transconductor is replaced by a nonlinear transconductor as shown in @fig-Nonlinear_analysis. If we assume that the OTA is a single-stage OTA like the simple 5T OTA and that the differential pair is biased in weak inversion then
\begin{equation}\label{eqn:iout}
  I_{out} = 2 I_b \cdot \tanh\left(\frac{V_{id}}{2n\,U_T}\right),
\end{equation}
where $V_{id} \triangleq V_{in+} - V_{in-}$ is the differential input voltage, $n$ the slope factor of the differential pair transistors and $U_T \triangleq kT/q$ the thermodynamic voltage. This differential voltage depends on the the input and output voltages according to
\begin{equation}\label{eqn:vid}
  V_{id} = -V = -\xi \cdot V_{in} - \beta \cdot V_{out},
\end{equation} 
with
\begin{align}
  \xi &= \frac{C_S}{C_S+C_F+C_{in}},\\
  \beta &= \frac{C_F}{C_S+C_F+C_{in}}.
\end{align}

We can then write the following differential equation at the output node accounting for the total load capacitcance $C_{out}$
\begin{equation}\label{eqn:dvoutdt}
  \frac{dV_{out}}{dt} = \frac{I_{out}}{C_{out}} = \frac{2I_b}{C_{out}} \cdot \tanh\left(\frac{V_{id}}{2n\,U_T}\right)
  = SR \cdot \tanh\left(\frac{V_{id}}{2n\,U_T}\right),
\end{equation}
where $SR$ is the slew rate
\begin{equation}
  SR = \frac{2I_b}{C_{out}}.
\end{equation}
The output voltage can be extracted from \eqref{eqn:vid} as
\begin{equation}\label{eqn:vout1}
  V_{out}(t) = - \frac{\xi \cdot V_{in} + V_{id}}{\beta}
\end{equation}
Let's define $x \triangleq V_{id}/(2 n U_T)$. Equation \eqref{eqn:vout1} then becomes
\begin{equation}\label{eqn:vout2}
  V_{out}(t) = - \frac{\xi \cdot V_{in} + 2 n U_T\,x}{\beta}
\end{equation}
Differentiating with respect to time leads to
\begin{equation}\label{eqn:dvoutdt2}
  \frac{dV_{out}}{dt} = -\frac{1}{\beta} \cdot \left(\xi\,\frac{dV_{in}}{dt} + 2 n U_T\,\frac{dx}{dt}\right)
\end{equation}
Since we want to derive the step response $V_{in}(t) = \Delta V_{in} = cte$ and \eqref{eqn:dvoutdt2} reduces to
\begin{equation}\label{eqn:dvoutdt3}
  \frac{dV_{out}}{dt} = -\frac{2 n U_T}{\beta} \cdot \frac{dx}{dt}.
\end{equation}
Replacing $dV_{out}/dt$ in \eqref{eqn:dvoutdt} by \eqref{eqn:dvoutdt3} results in
\begin{equation}
  -\frac{2 n U_T}{\beta} \cdot \frac{dx}{dt} = SR \cdot \tanh(x),
\end{equation}
which can be rewritten as
\begin{equation}\label{eqn:diffeq}
  -\frac{\beta\,SR}{2 n U_T} \cdot dt = \coth(x) \cdot dx.
\end{equation}
Differential equation \eqref{eqn:diffeq} can easily be integrated leading to
\begin{equation}\label{eqn:lambda_sinh}
  \Lambda \cdot e^{-\frac{\beta\,SR}{2 n U_T}\,t} = \sinh(x).
\end{equation}
The constant $\Lambda$ depends on the initial condition on $x$ at $t=0^+$  for which $V_{out}(t=0^+) = V_{out0}$ and
\begin{equation}
  \Lambda = \sinh\left(-\frac{\xi \cdot \Delta V_{in} + \beta \cdot V_{out0}}{2 n U_T}\right)
\end{equation}
In steady state, assuming that the OTA has a large dc gain, we can assume that $V_{id} \cong 0$ and hence $x=0$. The steady state value of the output voltage is then given by
\begin{equation}\label{eqn:voutinf}
  V_{out}(t \rightarrow \infty) = V_{out\infty} \cong -\frac{\xi}{\beta} \cdot \Delta V_{in}
\end{equation}
hence $-\xi \cdot \Delta V_{in} = \beta \cdot V_{out\infty}$ and $\Lambda$ writes
\begin{equation}\label{eqn:lambda}
  \Lambda = \sinh\left(\beta \, \frac{V_{out\infty} - V_{out0}}{2 n U_T}\right).
\end{equation}

Recalling that in weak inversion the transconductance is given by
\begin{equation}
  G_m = \frac{I_b}{n U_T}
\end{equation}
we can write
\begin{equation}\label{eqn:sr_2nut}
  \frac{SR}{2 n U_T} = \frac{2I_b/C_{out}}{2 n U_T} = \frac{G_m}{C_{out}} = \omega_u = \frac{1}{T_u}
\end{equation}
which is the unity-gain frequency.

Finally, replacing \eqref{eqn:lambda_sinh}, \eqref{eqn:voutinf}, \eqref{eqn:lambda} and \eqref{eqn:sr_2nut} in \eqref{eqn:vout2} results in the normalized large-signal step function
\begin{equation}\label{eqn:vout3}
  v_{out}(t) \triangleq \frac{V_{out}(t)}{V_{out\infty}} = 1 - \frac{2 n U_T}{\beta\,V_{out\infty}} \cdot \ln\left(y(t) + \sqrt{y^2(t)+1}\right),
\end{equation}
where
\begin{equation}
  y(t) = \sinh\left(\beta\,\frac{\Delta V_{out}}{2 n U_T}\right) \cdot e^{-\beta\,\frac{t}{T_u}}
  = \sinh\left(\beta\,\frac{\Delta V_{out}}{2 n U_T}\right) \cdot e^{-\frac{t}{\tau_p}},
\end{equation}
where $\Delta V_{out} = V_{out\infty} - V_{out0}$ is the step at the output after the output voltage has settled.

In the case the initial output voltage is zero $V_{out0}=0$, then we can rewrite \eqref{eqn:vout3} as
\begin{equation}\label{eqn:vout4}
  v_{out}(t) \triangleq \frac{V_{out}(t)}{V_{out\infty}} = 1- \frac{1}{B} \cdot \ln\left(y(t)+\sqrt{y(t)^2+1}\right)
\end{equation}
where
\begin{equation}
  y(t) = \sinh(B) \cdot e^{-\beta\,\frac{t}{T_u}} = \sinh(B) \cdot e^{-\frac{t}{\tau_p}}
\end{equation}
with parameter $B$ defined as
\begin{equation}
  B \triangleq \beta \cdot \frac{V_{out\infty}}{2 n U_T} = (1-\beta) \cdot \frac{\Delta V_{in}}{2 n U_T}
\end{equation}
which is proportional to the steady-state output voltage $V_{out\infty}$ and to the input step amplitude $\Delta V_{in}$.

The normalized output voltage is plotted in @fig-step_response versus the normalized time $t/\tau_p$ for various values of the parameter $B$ ranging from 0.001 (linear settling) to 10 (strongly nonlinear settling with slewing period dominating), assuming that $V_{out0}=0$ and hence that $\Delta V_{out}=V_{out\infty}$. The dot on each curve shows the point at which the slewing stops and the differential pair leaves saturation and goes back into the linear settling. @fig-step_response clearly illustrates that the slewing time can be much larger than the linear settling time and needs therefore to be accounted for when specifying the differential pair bias current $I_b$.

```{python}
#| label: fig-step_response
#| fig-cap: Step response according to \eqref{eqn:vout4} including the effect of slew-rate assuming that $V_{out0}=0$ and hence $\Delta V_{out}=V_{out\infty}$.

def stepres(x,B):
    #x is the time normalized to taup
    y=sinh(B)*exp(-x)
    vout=1-ln(y+sqrt(y**2+1))/B
    return vout

def timecrit(B):
    tcrit=ln(sinh(B)/sinh(1))
    return tcrit

def voutcrit(B):
    return 1-1/B

B0=0.001
B=[1,2,3,4,5,6,7,8,9,10]

Ncurves=len(B)
colors=plt.cm.rainbow(np.linspace(0, 1, Ncurves))
tcrit=np.zeros(Ncurves)
vcrit=np.zeros(Ncurves)
Npts=101
xmin=0
xmax=12
x=np.linspace(xmin,xmax,Npts,endpoint=True)
vout=np.zeros(Npts)

plt.style.use('plt_style_medium.mplstyle')
for k in range(0,Npts):
  vout[k]=stepres(x[k],B0)

plt.plot(x, vout, 'k-', label=f'$B =${B0:.3f}')

for m in range(0,Ncurves):
  tcrit[m]=timecrit(B[m])
  vcrit[m]=voutcrit(B[m])
  for k in range(0,Npts):
    vout[k]=stepres(x[k],B[m])
  plt.plot(x, vout, color=colors[m], label=f'$B =${B[m]:.0f}')

plt.plot(tcrit, vcrit, 'ro', markersize=4)

Bcrit=np.linspace(1e-3,13,Npts,endpoint=True)
tcrit=np.zeros(Npts)
vcrit=np.zeros(Npts)
for k in range(0,Npts):
  tcrit[k]=timecrit(Bcrit[k])
  vcrit[k]=voutcrit(Bcrit[k])
plt.plot(tcrit, vcrit, 'r--')

plt.xlim(xmin,xmax)
plt.xticks(np.arange(0,13,1))
plt.xlabel('$t\\,/\\,\\tau_p = \\beta\\,t\\,/\\,\\tau_u$')
plt.ylim(0,1)
plt.yticks(np.arange(0,1.1,0.1))
plt.ylabel('$V_{out}(t)\\,/\\,V_{out\\infty}$')
#plt.legend(loc='lower right')
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
if savePlot:
  saveFigures(savePlotPath, 'large_signal_step_response')
plt.show()
```


## Settling time
The corresponding settling time including the slewing period is then given by
\begin{equation}\label{eqn:tset1}
  t_{set} = \tau_p \cdot \ln\left[\frac{\sinh\left(\beta \cdot \frac{\Delta V_{out}}{2 n U_T}\right)}{\sinh(B \cdot \varepsilon_{set})}\right].
\end{equation}
In case $V_{out0}=0$ then $\Delta V_{out}=V_{out\infty}$ resulting in
\begin{equation}
  \beta \cdot \frac{\Delta V_{out}}{2 n U_T} = \beta \cdot \frac{V_{out\infty}}{2 n U_T} = B
\end{equation}
and hence \eqref{eqn:tset1} becomes
\begin{equation}\label{eqn:tset2}
  t_{set} \cong \tau_p \cdot \ln\left[\frac{\sinh(B)}{\sinh(B \cdot \varepsilon_{set})}\right].
\end{equation}

The settling time given by \eqref{eqn:tset2} is plotted in @fig-settling_time versus parameter $B$ for various values of the targeted precision $\varepsilon_{set}$. Note that for $\beta \cdot \Delta V_{out}/(2 n U_T) \ll 1$, we find the small-signal settling time
\begin{equation}\label{eqn:tset3}
  t_{set} \cong -\tau_p \cdot \ln(\varepsilon_{set}).
\end{equation}

For $\beta \cdot \Delta V_{out} > 10 n U_T$, the settling time increases about linearly with $\beta \cdot \Delta V_{out}/(2 n U_T)$ according to
\begin{equation}
  \frac{t_{set}}{\tau_p} \cong 0.918 \cdot B -\ln\left(\frac{\varepsilon_{set}}{0.1}\right).
\end{equation}
The above approximation is shown by the dashed lines in @fig-settling_time.

```{python}
#| label: fig-settling_time
#| fig-cap: Settling time including the effect of slew-rate.

def settling(B,err):
    tset=ln(sinh(B)/sinh(B*err))
    return tset

sciFormat = LogFormatterMathtext(base=10)
err=[1e-1,1e-2,1e-3,1e-4,1e-5]
Ncurves=len(err)
colors=plt.cm.rainbow(np.linspace(0, 1, Ncurves))
Npts=101
xmin=1e-3
xmax=20
x=np.linspace(xmin,xmax,Npts,endpoint=True)
tset=np.zeros(Npts)
tsetasy=np.zeros(Npts)
b=[0,1.3,3,7.5,10]

for m in range(0,Ncurves):
    for k in range(0,Npts):
        tset[k]=settling(x[k],err[m])
        tsetasy[k]=0.918*x[k]-ln(err[m]/err[0])
#    plt.plot(x, tset, color=colors[m], label=f'$\\varepsilon =$ {err[m]:.0e}')
    plt.plot(x, tsetasy, '--', color=colors[m])
    plt.plot(x, tset, color=colors[m], label='$\\varepsilon_{set} =$'+sciFormat(err[m]))

plt.xlim(xmin,xmax)
plt.xticks(np.arange(0,22,2))
plt.xlabel('$\\beta\\,\\Delta V_{out}\\,/\\,(2 n U_T)$')
plt.ylim(0,30)
#plt.yticks(np.arange(0,1.1,0.1))
plt.ylabel('$t_{set}\\,/\\tau_p = \\beta\\,t_{set}\\,/\\,\\tau_u$')
#plt.legend(loc='upper left', fontsize=14)
plt.legend(loc='center left', fontsize=9, bbox_to_anchor=(1, 0.5))
if savePlot:
  saveFigures(savePlotPath, 'large_signal_settling_time')
plt.show()
```

::: {.callout-note}
In SC filters the feedback gain $\beta$ often becomes close to one because the sampling capacitance $C_S$ needs to be much smaller than the feedback capacitance $C_F$ in order for the cut-off frequency to be sufficiently smaller than the Nyquist frequency $f_s/2$. This makes parameter $B$ larger and hence results in a larger settling time.
:::


## Example {#sec-example_large_signal}
```{python}
UT=25.6e-3
n=1.3
nUT=n*UT
fck=1e6
Ts=1/fck
tset=Ts/2
eset=1e-3
A0ideal=-1
Adc=1000
Cin=10e-15
CS=1e-12
CF=CS/abs(A0ideal)
CL=0.1e-12
beta=CF/(CF+CS+Cin)
#xi=CS/(CF+CS+Cin)
xi=beta-1
A0=A0ideal/(1+1/(beta*Adc))
Cout=CL+(1-beta)*CF
DVin=-1
Vout0=DVin*CS*CF/((CS+Cin)*(CF+CL)+CF*CL)
Voutinf=A0*DVin
DVout=Voutinf-Vout0
taup=tset/-ln(eset*(1-beta*Cout/CF))
#taup=-tset/ln(eset)
wp=1/taup
fp=wp/(2*pi)
wu=wp/beta
fu=wu/(2*pi)
Gm=wu*Cout
tauz=CF/Gm
wz=1/tauz
fz=wz/(2*pi)
Rout=Adc/Gm
Ib=Gm*nUT
Tu=Cout/Gm
```

In this section we will validate the results obtained by the nonlinear analysis including the slew-rate developped in @sec-nonlinear_step_response. We will use the same SC-amplifier than in the small-signal step case that are shown in @fig-SC_amplifier_phase1 and @fig-SC_amplifier_phase2. The SC-amplifier during the amplification phase $\Phi_2$ is simulated with the circuit shown in @fig-Nonlinear_analysis which includes a nonlinear transconductor modeling the nonlinear behavior coming from the input differential pair of a single-stage OTA. To simulate this circuit in ngspice we use the following netlist.

    XOTA1 0 1 out OTAtanh Gmval={Gm} Routval={Rout} Visatval={Visat}
    CL out 0 {CL}
    CF out 1 {CF}
    CS in 1 {CS}
    Cin in 0 {Cin}
    Vin in 0 DC 0 AC 1 PULSE ({V1} {V2} {td} {tr} {tf} {pw} {per} {np})
  
    * OTA with hyperbolic tangent V/I characteristics:
    * ------------------------------------------------
    .subckt OTAtanh inp inn out Gmval=10u Routval=1MEG Visatval=80m
    Bdm 0 out I=Gmval*Visatval*tanh(V(inp,inn)/Visatval)
    Rout out 0 {Routval}
    .ends

The nonlinear OTA of @fig-Nonlinear_analysis is described by subcircuit `OTAtanh` using a behavioral current source `Bdm` which models the differential output current of a differential pair biased in weak inversion according to \eqref{eqn:iout}. This is consistent with the assumption that was used in the above nonlinear analysis. Note that the same circuit is also used for the simulation of the small-signal case since for $V_{id} \ll V_{isat}$, the current of the behavioral source is simply equal to $I \cong G_m \cdot V_{id}$.

We now reuse the specifications already used for the small-signal case except the step size which is now much larger. The specifications are summarized in @tbl-example_large_step_specs and the calculated parameters are shown in @tbl-example_large_step1.

::: {.callout-warning}
In this example we need to use \eqref{eqn:vout3} instead of \eqref{eqn:vout4} because the initial output voltage value $V_{out0}$ is not zero.
:::

```{python}
#| label: tbl-example_large_step_specs
#| tbl-cap: Specifications for the small-signal step response.

table = [["Clock frequency","$f_{{ck}}$",f'{fck/1e6:.0f}',"$MHz$"],
         ["Clock period","$T_s$",f'{Ts/1e-6:.0f}',"$\\mu s$"],
         ["Settling time","$t_{{set}}$",f'{tset/1e-9:.0f}',"$ns$"],
         ["Settling error","$\\varepsilon_{{set}}$",f'{eset:.1e}',"-"],
         ["Ideal DC gain","$A_{{0,ideal}}$",f'{A0ideal:.0f}',"-"],
         ["OTA DC gain","$A_{{dc}}$",f'{Adc:.0e}',"-"],
         ["Feedback capacitance","$C_F$",f'{CF/1e-12:.0f}',"$pF$"],
         ["Load capacitance","$C_L$",f'{CL/1e-12:.1f}',"$pF$"],
         ["Input capacitance","$C_{{in}}$",f'{Cin/1e-15:.0f}',"$fF$"],
         ["Input step","$\\Delta V_{{in}}$",f'{DVin:.0f}',"$V$"]
         ]

Markdown(tabulate(
  table,
  headers=["Parameter","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center")
))
```

```{python}
#| label: tbl-example_large_step1
#| tbl-cap: Calculated parameters for the large-signal step response calculated with the small-signal settling time estimation.

table = [["Source capacitance","$C_S$",f'{CS/1e-12:.0f}',"$pF$"],

         ["Feedback gain","$\\beta$",f'{beta:.3f}',"-"],
         ["Effective DC gain","$A_0$",f'{A0:.3f}',"-"],
         ["Total output capacitance","$C_{{out}}$",f'{Cout/1e-12:.3f}',"$pF$"],
         ["Time constant","$\\tau_p$",f'{taup/1e-9:.3f}',"$ns$"],
         ["Time constant","$\\tau_z$",f'{tauz/1e-9:.3f}',"$ns$"],
         ["Pole","$f_p$",f'{fp/1e6:.3f}',"$MHz$"],
         ["Zero","$f_z$",f'{fz/1e6:.3f}',"$MHz$"],
         ["Initial output voltage","$V_{{out}}(t=0^+)$",f'{Vout0/1e-3:.3f}',"$mV$"],
         ["Final output voltage","$V_{{out}}(t \\rightarrow \\infty)$",f'{Voutinf/1e-3:.3f}',"$mV$"],
         ["Gain-bandwidth product","$f_u$",f'{fu/1e6:.3f}',"$MHz$"],
         ["OTA Transconductance","$G_m$",f'{Gm/1e-6:.3f}',"$\\mu A/V$"],
         ["OTA output resistance","$R_{{out}}$",f'{Rout/1e6:.3f}',"$M \\Omega$"]
         ]

Markdown(tabulate(
  table,
  headers=["Parameter","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center")
))
```

```{python}
#| label: fig-ng_large_step
#| fig-cap: "Step response of the OTA as a voltage follower for a large input step highlighting the slew-rate effect."

simtype = ".tran"
fileName = circuitName + simtype
simulationPath = "./Simulations/ngspice/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
simulationVoltages = simulationPath + fileName + ".ic"
ngspiceDataFile = simulationPath + circuitName + version + simtype + "2.dat"
ngspiceNodeVoltageFile = simulationPath + circuitName + version + simtype + "2.ic"

Visat=2*n*UT
V1=0
V2=DVin
td=0.1e-6
tr=10e-12
tf=10e-12
pw=1
per=1
nper=0

if newSim:
  paramstr = '\n'.join((
  f'.param Gm={Gm/1e-6:.3f}u Rout={Rout/1e6:.3f}MEG Visat={Visat/1e-3:.1f}m',
  f'.param CL={CL/1e-15:.0f}f CF={CF/1e-15:.0f}f CS={CS/1e-12:.0f}p Cin={Cin/1e-15:.0f}f'
  ))
  with open(simulationPath+'parameters.par', 'w') as f:
    f.write(paramstr)
  pulsestr = f'.param V1={V1:.3f} V2={V2:.3f} td={td:.3e} tr={tr:.3e} tf={tf:.3e} pw={pw:.3e} per={per:.3e} np={nper:.0f}'
  with open(simulationPath+'pulse.par', 'w') as f:
    f.write(pulsestr)
  Nsteps=1000
  tstart=0
  tstop=1.5e-6
  tstep=(tstop-tstart)/Nsteps
  simpar = '\n'.join((
    f'.csparam tstep={tstep:.3e}',
    f'.csparam tstop={tstop:.3e}',
    f'.csparam tstart={tstart:.0f}'
    ))
  simparFile = simulationPath + "simulation.tran.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting tran simulation data file because it will be overwritten by the next tran simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

tsim=df_sim['time'].to_numpy()
Vinsim=df_sim['v(in)'].to_numpy()
Voutsim=df_sim['v(out)'].to_numpy()

Npts=len(tsim)
tmin=tsim[0]
tmax=tsim[Npts-1]

Voutthesma=np.zeros(Npts)
Voutthe=np.zeros(Npts)

for k in range(0,Npts):
  if tsim[k]<td:
    Voutthe[k]=0
  else:
    Voutthesma[k]=DVin*A0*(1-(1+tauz/taup)*exp(-(tsim[k]-td)/taup))
    y=sinh(beta*DVout/(2*nUT))*exp(-beta*(tsim[k]-td)/Tu)
    Voutthe[k]=Voutinf*(1-2*nUT/(beta*Voutinf)*ln(y+sqrt(y**2+1)))

#plt.plot([td/1e-6,(td+1/(2*pi*GBWthe))/1e-6],[0,DVin/1e-3], 'k--', linewidth=lw)
#plt.plot([0,tmax/1e-6],[Voutfin/1e-3,Voutfin/1e-3], 'k--', linewidth=lw)
plt.plot(tsim/1e-6,Vinsim/1e-3,'b-', label='Input')
plt.plot(tsim/1e-6,-Vinsim/1e-3,'b--')
plt.plot(tsim/1e-6,Voutthesma/1e-3,'m--', label='Output (small-signal)')
plt.plot(tsim/1e-6,Voutthe/1e-3,'r-', label='Output (Theory)')
plt.plot(tsim/1e-6,Voutsim/1e-3,'ro', label='Output (Sim.)', markevery=20, markersize=4)
plt.xlim(tmin/1e-6,tmax/1e-6)
#plt.xticks(np.arange(0,1.2,0.1))
plt.xlabel('Time [$\\mu s$]')
#plt.ylim(0,350)
plt.ylabel('$\\Delta V_{in}$, $\\Delta V_{out}$ [mV]')
plt.legend(loc='best')
textstr = '\n'.join((
  f'$\\Delta V_{{in}} =$ {DVin:.0f} $V$',
  f'$\\varepsilon_{{set}} =$ {eset:.0e}',
  f'$C_S =$ {CS/1e-12:.0f} $pF$',
  f'$C_F =$ {CF/1e-12:.0f} $pF$',
  f'$C_L =$ {CL/1e-15:.0f} $fF$',
  f'$C_{{in}} =$ {Cin/1e-15:.0f} $fF$',
  f'$C_{{out}} =$ {Cout/1e-15:.0f} $fF$',
  f'$\\beta =$ {beta:.3f}',
  f'$A_{{0,ideal}} =$ {A0ideal:.0f}',
  f'$A_{{dc}} =$ {Adc:.0f}',
  f'$G_m =$ {Gm/1e-6:.1f} $\\mu A/V$',
  f'$\\tau_p =$ {taup/1e-9:.1f} $ns$',
  f'$\\tau_z =$ {tauz/1e-9:.1f} $ns$',
  f'$V_{{out}}(0) =$ {Vout0/1e-3:.0f} $mV$',
  f'$V_{{out}}(t \\rightarrow \\infty) =$ {Voutinf/1e-3:.0f} $mV$'))
plt.text(1.05, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

The simulation result is compared to the theoretical small- and large-signal step responses given by \eqref{eqn:vout_small} and \eqref{eqn:vout3} in @fig-ng_large_step. We first can observe a perfect agreement between the simulation and the theoretical expression, which validates the analytical derivation of @sec-nonlinear_step_response. Comparing the large-signal step response to the small-signal step response (corresponding to the dashed purple curve), we observe that the signal doesn't settle within the `{python} f'{tset/1e-9:.0f}'` $ns$ settling time. This is simply due to the fact that we have used the small-signal settling time expression \eqref{eqn:tset_linear} to derive the required transconductance.

```{python}

UT=25.6e-3
n=1.3
nUT=n*UT
fck=1e6
Ts=1/fck
tset=Ts/2
eset=1e-3
A0ideal=-1
Adc=1000
Cin=10e-15
CS=1e-12
CF=CS/abs(A0ideal)
CL=0.1e-12
beta=CF/(CF+CS+Cin)
#xi=CS/(CF+CS+Cin)
A0=A0ideal/(1+1/(beta*Adc))
Cout=CL+(1-beta)*CF
DVin=-1
Vout0=DVin*CS*CF/((CS+Cin)*(CF+CL)+CF*CL)
Voutinf=A0*DVin
DVout=Voutinf-Vout0
taup=tset/ln(sinh(beta*DVout/(2*nUT))/sinh(beta*Voutinf/(2*nUT)*eset))
wp=1/taup
fp=wp/(2*pi)
wu=wp/beta
fu=wu/(2*pi)
Gm=wu*Cout
tauz=CF/Gm
wz=1/tauz
fz=wz/(2*pi)
Rout=Adc/Gm
Ib=Gm*nUT
Tu=Cout/Gm

taupsma=tset/-ln(eset*(1-beta*Cout/CF))
wpsma=1/taupsma
wusma=wpsma/beta
Gmsma=wusma*Cout
tauzsma=CF/Gmsma
```

To make sure that the output voltage settles within the desired settling time and for the given settling error, we need to calculate the required transconductance using the large-signal settling time given in \eqref{eqn:tset1}. The transconductance is now $G_m =$ `{python} f'{Gm/1e-6:.1f}'` $\mu A/V$ which is `{python} f'{Gm/Gmsma:.1f}'` times larger than the small-signal estimation $G_m =$ `{python} f'{Gmsma/1e-6:.1f}'` $\mu A/V$. The parameters are given in @tbl-example_large_step2 and the simulation is compared to the theoretical step response in @fig-ng_large_step2.

```{python}
#| label: tbl-example_large_step2
#| tbl-cap: Parameters for the large-signal step response calculated with the large-signal settling time estimation.

table = [["Source capacitance","$C_S$",f'{CS/1e-12:.0f}',"$pF$"],

         ["Feedback gain","$\\beta$",f'{beta:.3f}',"-"],
         ["Effective DC gain","$A_0$",f'{A0:.3f}',"-"],
         ["Total output capacitance","$C_{{out}}$",f'{Cout/1e-12:.3f}',"$pF$"],
         ["Time constant","$\\tau_p$",f'{taup/1e-9:.3f}',"$ns$"],
         ["Time constant","$\\tau_z$",f'{tauz/1e-9:.3f}',"$ns$"],
         ["Pole","$f_p$",f'{fp/1e6:.3f}',"$MHz$"],
         ["Zero","$f_z$",f'{fz/1e6:.3f}',"$MHz$"],
         ["Initial output voltage","$V_{{out}}(t=0^+)$",f'{Vout0/1e-3:.3f}',"$mV$"],
         ["Final output voltage","$V_{{out}}(t \\rightarrow \\infty)$",f'{Voutinf/1e-3:.3f}',"$mV$"],
         ["Gain-bandwidth product","$f_u$",f'{fu/1e6:.3f}',"$MHz$"],
         ["OTA Transconductance","$G_m$",f'{Gm/1e-6:.3f}',"$\\mu A/V$"],
         ["OTA output resistance","$R_{{out}}$",f'{Rout/1e6:.3f}',"$M \\Omega$"]
         ]

Markdown(tabulate(
  table,
  headers=["Parameter","Symbol","Value","Unit"],
  numalign="center",
  stralign="center",
  colalign=("left","center","center","center")
))
```

```{python}
#| label: fig-ng_large_step2
#| fig-cap: "Step response of the OTA as a voltage follower (inverter) for a large input step with the transconductance calculated with the large-signal settling time estimation."

simtype = ".tran"
fileName = circuitName + simtype
simulationPath = "./Simulations/ngspice/"
simulationFile = simulationPath + fileName + ".cir"
simulationLog = simulationPath + fileName + ".log"
simulationData = simulationPath + fileName + ".dat"
simulationVoltages = simulationPath + fileName + ".ic"
ngspiceDataFile = simulationPath + circuitName + version + simtype + "3.dat"
ngspiceNodeVoltageFile = simulationPath + circuitName + version + simtype + "3.ic"

Visat=2*n*UT
V1=0
V2=DVin
td=0.1e-6
tr=10e-12
tf=10e-12
pw=1
per=1
nper=0

if newSim:
  paramstr = '\n'.join((
  f'.param Gm={Gm/1e-6:.3f}u Rout={Rout/1e6:.3f}MEG Visat={Visat/1e-3:.1f}m',
  f'.param CL={CL/1e-15:.0f}f CF={CF/1e-15:.0f}f CS={CS/1e-12:.0f}p Cin={Cin/1e-15:.0f}f'
  ))
  with open(simulationPath+'parameters.par', 'w') as f:
    f.write(paramstr)
  pulsestr = f'.param V1={V1:.3f} V2={V2:.3f} td={td:.3e} tr={tr:.3e} tf={tf:.3e} pw={pw:.3e} per={per:.3e} np={nper:.0f}'
  with open(simulationPath+'pulse.par', 'w') as f:
    f.write(pulsestr)
  Nsteps=1000
  tstart=0
  tstop=0.6e-6
  tstep=(tstop-tstart)/Nsteps
  simpar = '\n'.join((
    f'.csparam tstep={tstep:.3e}',
    f'.csparam tstop={tstop:.3e}',
    f'.csparam tstart={tstart:.0f}'
    ))
  simparFile = simulationPath + "simulation.tran.par"
  with open(simparFile, 'w') as f:
    f.write(simpar)
  #print('Starting NGSpice simulation...\n')
  result = subprocess.run(f"""ngspice_con -b -o "{simulationLog}" "{simulationFile}" """, shell=True, capture_output=True, text=True)
  # We need to copy the resulting tran simulation data file because it will be overwritten by the next tran simulation
  shutil.copy2(simulationData, ngspiceDataFile)
  # We need to copy the resulting operating point information file because it will be overwritten by subsequent simulations
  shutil.copy2(simulationVoltages, ngspiceNodeVoltageFile)

df_sim=pd.read_table(ngspiceDataFile, sep=' +', engine='python')

tsim=df_sim['time'].to_numpy()
Vinsim=df_sim['v(in)'].to_numpy()
Voutsim=df_sim['v(out)'].to_numpy()

Npts=len(tsim)
tmin=tsim[0]
tmax=tsim[Npts-1]

Voutthesma=np.zeros(Npts)
Voutthe=np.zeros(Npts)

for k in range(0,Npts):
  if tsim[k]<td:
    Voutthe[k]=0
  else:
    Voutthesma[k]=DVin*A0*(1-(1+tauzsma/taupsma)*exp(-(tsim[k]-td)/taupsma))
    y=sinh(beta*DVout/(2*nUT))*exp(-beta*(tsim[k]-td)/Tu)
    Voutthe[k]=Voutinf*(1-2*nUT/(beta*Voutinf)*ln(y+sqrt(y**2+1)))

#plt.plot([td/1e-6,(td+1/(2*pi*GBWthe))/1e-6],[0,DVin/1e-3], 'k--', linewidth=lw)
#plt.plot([0,tmax/1e-6],[Voutfin/1e-3,Voutfin/1e-3], 'k--', linewidth=lw)
plt.plot(tsim/1e-6,Vinsim/1e-3,'b-', label='Input')
plt.plot(tsim/1e-6,-Vinsim/1e-3,'b--')
plt.plot(tsim/1e-6,Voutthesma/1e-3,'m--', label='Output (small-signal)')
plt.plot(tsim/1e-6,Voutthe/1e-3,'r-', label='Output (Theory)')
plt.plot(tsim/1e-6,Voutsim/1e-3,'ro', label='Output (Sim.)', markevery=20, markersize=4)
plt.xlim(tmin/1e-6,tmax/1e-6)
#plt.xticks(np.arange(0,1.2,0.1))
plt.xlabel('Time [$\\mu s$]')
#plt.ylim(0,350)
plt.ylabel('$\\Delta V_{in}$, $\\Delta V_{out}$ [mV]')
plt.legend(loc='lower right')
textstr = '\n'.join((
  f'$\\Delta V_{{in}} =$ {DVin:.0f} $V$',
  f'$\\varepsilon_{{set}} =$ {eset:.0e}',
  f'$C_S =$ {CS/1e-12:.0f} $pF$',
  f'$C_F =$ {CF/1e-12:.0f} $pF$',
  f'$C_L =$ {CL/1e-15:.0f} $fF$',
  f'$C_{{in}} =$ {Cin/1e-15:.0f} $fF$',
  f'$C_{{out}} =$ {Cout/1e-15:.0f} $fF$',
  f'$\\beta =$ {beta:.3f}',
  f'$A_{{0,ideal}} =$ {A0ideal:.0f}',
  f'$A_{{dc}} =$ {Adc:.0f}',
  f'$G_m =$ {Gm/1e-6:.1f} $\\mu A/V$',
  f'$\\tau_p =$ {taup/1e-9:.1f} $ns$',
  f'$\\tau_z =$ {tauz/1e-9:.1f} $ns$',
  f'$V_{{out}}(0) =$ {Vout0/1e-3:.0f} $mV$',
  f'$V_{{out}}(t \\rightarrow \\infty) =$ {Voutinf/1e-3:.0f} $mV$'))
plt.text(1.05, 0.5, textstr, ha='left', va='center', size=9, transform=plt.gca().transAxes,
         bbox={'facecolor':'w', 'alpha':1.0, 'pad':5})
plt.show()
```

We see in @fig-ng_large_step2 that the output voltage now settles as required within the  `{python} f'{tset/1e-9:.0f}'` $ns$ settling time. We also see that the small-signal settling corresponding to the dashed purple curve is now much faster simply because the transconductance is much larger and hence the time constant $\tau_p$ much shorter.

# Conclusion
In this notebook we have first derived the step response and settling time of a capacitively coupled OTA in linear operation. We then performed a nonlinear analysis that includes the effect of slewing due to the nonlinear behavior of the OTA input differential pair. The model allows to have a more accurate estimation of the large-signal settling time which might be dominant in low-power SC circuits such as amplifiers or filters. The analytical nonlinear step response has been succesfully validated with ngspice simulation.

# References
